{
    "collab_server" : "",
    "contents" : "# CarbCalc methods in R\n\n\n#cpragma mark - numerical methods\n\n# ** For now, use f() as general QUARTIC (or cubic or quadratic)\n# ** to be solved by calcPhForAlkDic()...\nfOfx <- function(x,a,b,c,d,e) {\n  return(a*x*x*x*x + b*x*x*x + c*x*x + d*x + e)\n}\n\n# ** code the secant method to solve 2nd-, 3rd-, & 4th-degree polynomials\ncalcSecantMethod <- function(q4,q3,q2,q1,q0) {\n  # print('IN SECANT METHOD...')\n  ans = polyroot(c(q0, q1, q2, q3, q4))\n  # print(ans)\n# ***************************************\n# Method to carry out the secant search\n# ***************************************\n\n# ** define the number of iterations\n  n <- 500\n  del <- 10^(-10)\n  a <- 0\n  b <- 40\n  \n  # ** define the interval, dz, and ...\n  dx <- (b - a) / 10\n  x <- (a + b) / 2\n# ***************************************\n    \n  k <- 0\n  \n  # ** increment the interval\n  x1 = x + dx\n  \n  # ** while the increment is greater than the tolerance\n  # ** and the iterations are less than the max number thereof\n  # ** NB ** for iOS, MUST USE ---> fabs() <----, not abs() !!\n    while ((abs(dx) > del) && (k < n)) {\n      \n      d <- fOfx(x1,q4,q3,q2,q1,q0) - fOfx(x,q4,q3,q2,q1,q0)\n      x2 <- x1 - (fOfx(x1,q4,q3,q2,q1,q0) * (x1 - x)) / d\n      \n      x  <- x1\n      x1 <- x2\n      \n      dx <- x1 - x\n      \n      k <- k + 1\n    }\n  \n#  if(k == n) NSLog(@\"Convergence not found after %d iterations\",n)\n  \n  return(x1)\n}\n\n# ---- density calcs ----\n\n# ** NB: TEMP IS IN CELCIUS, ** NOT ** KELVIN\ncalcRhoFW <- function(t) {\n  # **  input temp, dT, in KELVIN\n  # ** define a local temp in CELCIUS\n  \n  tempInCelcius <- t - 273.15\n  \n  rhoFw <- 999.842594 + 0.06793952 * tempInCelcius\n  rhoFw <- rhoFw + (-0.009095290) * tempInCelcius * tempInCelcius\n  \n  rhoFw <- rhoFw +  0.0001001685 * tempInCelcius^3\n  rhoFw <- rhoFw + -0.000001120083 * tempInCelcius^4\n  rhoFw <- rhoFw +  0.000000006536332 * tempInCelcius^5\n  \n  return(rhoFw)\n}\n\n\n# ** NB: TEMP IS IN CELCIUS, ** NOT ** KELVIN\n# ***** SW rho(T, S) in kg/m3 (g/l)\ncalcRho <- function(t,s) {\n  # ** input temp, dT, in KELVIN\n  # ** define a local temp in CELCIUS\n  tempInCelcius = t - 273.15\n  \n  A <-      0.824493 - 0.0040899 * tempInCelcius\n  A <- A +  0.000076438 * tempInCelcius * tempInCelcius\n  A <- A + -0.00000082467 * tempInCelcius^3\n  A <- A +  0.0000000053875 * tempInCelcius^4\n  \n  B <-     -0.00572466 + 0.00010227 * tempInCelcius\n  B <- B + -0.0000016546 * tempInCelcius * tempInCelcius\n  \n  C <- 0.00048314\n  \n  # ** NB: SEND calcRhoFW temp in **KELVIN**, it will change to C\n  # **     Why? In case need to call calcRhoFW from another\n  # **     method that send temp in KELVIN\n  myRhoSW   <-  calcRhoFW(t) + A * s\n  myRhoSW   <- myRhoSW + B * s^1.5\n  myRhoSW   <- myRhoSW + C * s * s\n  \n  return(myRhoSW)\n}\n\n\n# ---- pH 'slope' & 'intercept' calcs\n\nphLineSlope <- function(temp,sal,ph) {\n  \n  return(alphaOne(temp,sal,ph) + 2 * alphaTwo(temp,sal,ph))\n}\n\nphLineIntercept <- function(temp,sal,ph) {\n  \n  return(calcHydroxide(ph,temp,sal) - calcHydronium(ph) + calcBorate(ph,temp,sal))\n}\n\n\n#pragma mark - [Alk] from DIC\ncalcAlkOfDic <- function(dic,ph,temp,sal) {\n  \n  alk <- dic * phLineSlope(temp,sal,ph)\n                \n  alk <- alk + calcHydroxide(ph,temp,sal)\n  \n  alk <- alk - calcHydronium(ph)\n  \n  alk <- alk + calcBorate(ph,temp,sal)\n  \n#   print('----------')\n#   print(alk)\n#   print(phLineIntercept(temp,sal,ph) + dic*phLineSlope(temp,sal,ph))\n#   print(1000*phLineIntercept(temp,sal,ph))\n#   print(phLineSlope(temp,sal,ph))\n#   print('----------')\n  \n  return(alk)\n}\n\n\n#pragma mark - DIC from [Alk]\n\n# calc DIC for a given [Alk] & pH -- COULD USE WHEN pH is pHCrit for CO2Crit, no ???\n# ** What are the units of DIC? Do [Alk] units need converted from \"/liter\" to \"/kg\" ?\ncalcDicOfAlk <- function(alk,ph,temp,sal) {\n  \n  m <- phLineSlope(temp,sal,ph)\n  \n  dic <- (alk - calcHydroxide(ph,temp,sal) - \n                  calcBorate(ph,temp,sal) + \n                  calcHydronium(ph)) / m;\n  \n  return(dic)\n}\n\n\n# ** FREE scale?\ncalcBorate <- function(ph,temp,sal) {\n  \n  concB <- calcBorateConcOfSalinity(sal)\n  \n  myKB <- calcBorateFactor(temp,sal)\n  \n  borate <- myKB * concB / (myKB + 10^(-ph))\n  \n  return(borate)\n}\n\n\ncalcBorateConcOfSalinity <- function(sal) {\n  \n  concB <- 0.000232 * sal / (10.811 * 1.80655)\n  \n  return(concB)\n}\n\ncalcBorateFactor <- function(temp,sal) {\n  \n  A <- 148.0248 + 137.1942 * sqrt(sal) + 1.62142 * sal\n  B <- -8966.90 - 2890.53 * sqrt(sal) - 77.942 * sal + 1.728 * sal^(1.5) - 0.0996 * sal * sal\n  C <- -24.4344 - 25.085 * sqrt(sal) - 0.2474 * sal\n  D <- 0.053105 * sqrt(sal)\n  \n  K_BOH3 <- exp(A + B/temp + C*log(temp) + D*temp);\n  \n  ans <- 10^-(-log10(K_BOH3)+log10(ahFreeToTotFactor(sal,temp,0)))\n  \n  return (ans)\n}\n\ncalcHydronium <- function(ph) {\n  \n  return(10.0^(-ph))\n}\n\ncalcHydroxide <- function(ph,temp,sal) {\n  \n  kWToTheTen <- log10(calcKWMehrbach(temp,sal))\n  \n  return(10.0^(kWToTheTen + ph))\n}\n\n#pragma mark - Kw, H3O, OH\n\n# KW(T, S) from Miller-o (1995),\n# in Dickson & Goyet (1994), Ch. 5, p. 18\n# pH scale: TOTAL  units: (mol/kg-soln)^2\ncalcKWMehrbach <- function(temp,sal) {\n  \n  expSum <- 148.9652;     # NB: \"148.965 02\" in Zeebe & Wolf-Gladrow code\n  expSum <- expSum - 13847.26 / temp\n  expSum <- expSum - 23.6521 * log(temp)\n  expSum <- expSum + (-5.977 + (118.67 / temp) + 1.0495 * log(temp)) * sqrt(sal)\n  expSum <- expSum - 0.01615 * sal;\n  \n  KW <- exp(expSum);   # still on TOTAL scale\n  pKW <- -log10(KW);   # still on TOTAL scale\n  \n  # ** NB: convert to FREE pH scale, as per AquaEnv\n  pKW <- pKW + log10(ahFreeToTotFactor(sal,temp,0.0))\n  \n  return(10^(-pKW))\n}\n\n# ---- alpha-sub-i ----\n\nalphaZero <- function(temp,sal,ph) {\n  \n# NB: declare p LOCALLY until incorporate in calcs\n  p <- 0.0\n  \n  h <- calcHydronium(ph)\n  \n  k1 <- getK1(temp,sal,p)\n  \n  k2 <- getK2(temp,sal,p)\n  \n  numerator <- h * h\n  \n  return (numerator / calcAlphaDenom(h,k1,k2))\n}\n\n\nalphaOne <- function(temp,sal,ph) {\n  \n  # NB: define p LOCALLY until incorporate in calcs\n  p <- 0.0 \n  \n  h <- calcHydronium(ph)\n  \n  k1 <- getK1(temp,sal,p)\n  \n  k2 <- getK2(temp,sal,p)\n  \n  numerator <- h * k1;\n  \n  return (numerator / calcAlphaDenom(h,k1,k2))\n}\n\nalphaTwo <- function(temp,sal,ph) { \n  \n  # NB: define p LOCALLY until incorporate in calcs\n  p <- 0.0 \n  \n  h <- calcHydronium(ph)\n  \n  k1 <- getK1(temp,sal,p)\n  \n  k2 <- getK2(temp,sal,p)\n  \n  numerator <- k1 * k2;\n  \n  return (numerator / calcAlphaDenom(h,k1,k2))\n}\n\ncalcAlphaDenom <- function(h,k1,k2) {\n  \n  return(h*h + k1 * h + k1 * k2)\n}\n\n# T- and S-dependent K1 from Millero et al. (2006)\n# ** pH scale: SWS for calculation, FREE returned\ngetK1 <- function(temp,sal,p) {\n  \n  sqrtS <- sqrt(sal)\n  lnT <- log(temp)\n  \n  pK1z <- -126.34048 + (6320.813 / temp) + 19.568224 * lnT # was \"19.56822..\"\n  A <- 13.4191 * sqrtS + 0.0331 * sal - 0.0000533 * sal * sal\n  B <- -530.123 * sqrtS - 6.103 * sal\n  C <- -2.06950 * sqrtS\n  pK1 <- pK1z + A + (B / temp) + C * lnT\n  \n  # ** NB: THIS conversion puts it on the FREE pH scale *from* the SWS scale, as per AquaEnv\n  # **     factor for sws2free = 1.0 / ahFreeToSwsFactorForSalinity:temp:pressure:\n  # **     when dealing with -log10, -log10(1 / ah) = -(-log10(ah)) = +log10(ahFreeToSWSFactor...)\n  pK1 <- pK1 + log10(ahFreeToSwsFactor(sal,temp,0.0))\n  \n  # ?? NB: no concentration scale conversion needed, as both on molinity [sic]\n \n  return(10^(-pK1)) # K1\n}\n\n\n# T- and S-dependent K2 from Millero et al. (2006)\n# ** pH scale: SWS for calculation\n# ** Return: K2 -- not pK2 -- on FREE pH scale\ngetK2 <- function(temp,sal,p) {\t\n  \n  sqrtS <- sqrt(sal)\n  lnT <- log(temp)\n  \n  pK2z <- -90.18333 + (5143.692 / temp) + 14.613358 * lnT\n  \n  A <- 21.0894 * sqrtS + 0.1248 * sal - 0.0003687 * sal * sal # was \"21.08945\"\n  B <- -772.483 * sqrtS - 20.051 * sal\n  C <- -3.3336 * sqrtS  # was \"-3.3336\" or \"3.32254\"\n  \n  # ** NB: THIS pK2 is on the SWS pH scale\n  pK2 <- pK2z + A + (B / temp) + C * lnT;\n  \n  pK2 <- pK2 + log10(ahFreeToSwsFactor(sal,temp,0.0))\n  \n  return(10^(-pK2))\n}\n\n# ---- Proton Activity Coefficient ----\n\ncalcProtonActivityCoeffZg <- function(temp,sal,p) {\n  \n  rootGamma <- sqrt(calcIonicStrength(sal))\n  \n  myHActivityCoeff <- 1820000.0 * (79 * temp)^(-1.5)\n  \n  myHActivityCoeff <- myHActivityCoeff * ((rootGamma / (1 + rootGamma)) - 0.2 * calcIonicStrength(sal))\n  \n  myHActivityCoeff <- 10^(-myHActivityCoeff)\n\n  return(myHActivityCoeff)\n}\n\n\n# ---- ah pH Conversion Methods ----\n# ** NB: calcKSdicksonOfTemp: uses ionic strength calc,\n# **     which can return I(s) in either MOLAL or MOLIN\n\nahMolalToMolinforSalinity <- function(sal) {\n  \n  return(1.0 - 0.001005 * sal)\n}\n\n\nahFreeToSwsFactor <- function(sal,temp,p) {\n  \n  return(1 + (calcTS(sal) / calcKsDickson(temp,sal,0.0)) + \n           (calcTF(sal) / calcKfDickson(temp,sal,0.0)))\n}\n\n\nahFreeToTotFactor <- function(sal,temp,p) {\n  \n  return(1 + (calcTS(sal) / calcKsDickson(temp,sal,0.0)))\n}\n\n\nahSwsToNbsFactor <- function(sal,temp,p) {\n  \n  return(calcProtonActivityCoeffZg(temp,sal,0.0) / ahMolalToMolinforSalinity(sal))\n}\n\n\n# NB: pH(NBS) = pH(Free) - \n#               log10(ahFreeToSwsFactor(S,T(Kelvin),0)) - \n#               log10(ahSwsToNbsFactor())\nphNbsToPhFree <- function(ph,sal,temp,p) {\n  \n  return(ph + log10(ahSwsToNbsFactor(sal,temp,p)) + log10(ahFreeToSwsFactor(sal,temp,p)))\n}\n\n\n# pragma mark - total fluoride & total sulfide\ncalcTF <- function(sal) {\n  \n  return(0.0000019522 * sal)\n}\n\ncalcTS <- function(sal) {\n  \n  return(0.0008067267 * sal)\n}\n\n# pH scale: FREE\n# concentration scale: mole/kg-H2O ?? -> molin...?\ncalcKfDickson <- function(temp,sal,p) {\n  \n  fluorFactor1 <- 1590.2 / temp\n  fluorFactor2 <- -12.641\n  fluorFactor3 <- 1.525 * sqrt(calcIonicStrength(sal))\n  \n  # ** NB: molalToMolin factor in sqrt()...\n  #    double fluorFactor3 = 1.525 * sqrt([self calcIonicStrength:s] * (1.0 - 0.001005 * s));\n  \n  molal2molin <- log(1.0 - 0.001005 * sal)\n  \n  KF <- fluorFactor1 + fluorFactor2 + fluorFactor3 + molal2molin\n  \n  return(exp(KF))\n}\n\n# bisulfate dissociation\n# Dickson (1990); DOE (1994), ch. 5 p. 13; Z & W-G (2001) p. 260\n# pH scale: Free \n# concentration scale: mol/kg-H2O, CONVERTED TO AND RETURNED AS mol/kg-soln (molin)\n# **** NB **** if called from within pH conversion, T already C -> K *******\n# **** NB **** else if called from getKS(), must add 273.15 in call ****************\ncalcKsDickson <- function(temp,sal,p) {\n  \n  # ** NB: ionic strength calc now returns molal, so\n  # **     change to molin (mol/kg-soln) here for this calc\n  #    double myIS = [self calcIonicStrength:s] * (1.0 - 0.001005 * s);\n  myIS <- calcIonicStrength(sal)\n  \n  sulfFactor1 <- 141.328 - 4276.1 / temp\n  sulfFactor2 <- -23.093 * log(temp)\n  sulfFactor3 <- ( 324.57 - 47.986 * log(temp) - 13856 / temp) * sqrt(myIS)\n  sulfFactor4 <- (-771.54 + 114.723 * log(temp) + 35474 / temp) * myIS\n  sulfFactor5 <- -2698.0 * myIS^(1.5) / temp\n  sulfFactor6 <-  1776.0 * myIS^2 / temp\n  \n  molal2molin <- log(1.0 - 0.001005 * sal)\n  \n # ** in mol/kg-soln (MOLIN)\n  KS <- sulfFactor1 + sulfFactor2 + sulfFactor3 + sulfFactor4 + sulfFactor5 + sulfFactor6 + molal2molin\n  \n # ** in mol/kg-H2O (MOLAL)\n #\tdouble KS = sulfFactor1 + sulfFactor2 + sulfFactor3 + sulfFactor4 + sulfFactor5 + sulfFactor6;\n  \n  return(exp(KS))\n}\n\n\n# pragma mark - ionic strength (in molal)\n# ** calc ionic strength for SW from salinity\n# ** (for low-salinity solns, implement Butler's formulae)\n# ** concentration scale: mol/kg-H2O (molal)\n# ** CONVERT TO MOLIN??\ncalcIonicStrength <- function(sal) {\n  \n  myIS <- 19.924 * sal / (1000.0 - 1.005 * sal) # mole/kg-H2O (molal)\n  #//    myIS *= 1.0 - 0.001005 * sal           # mole/kg-soln (molin)\n  return(myIS)\n}\n\n# ---- calc Critical CO2 border ----\n# return: g/kg-soln\n\ncalcCo2OfDic <- function(dic,t,s,ph) {\n  \n  myCo2 <- dic * alphaZero(t,s,ph)\n  \n  # return mg/kg\n  myCo2 <- 44.0096 * myCo2\n  \n  return(myCo2)\n}\n\n# used to insure that the unsafe CO2 region on the Deffeyes Dgm is filled properly \ncalcPhForCritCO2FromDIC <- function(dic,co2Crit,t,s) {\n  \n  # calculate pH at which, for a given DIC, [CO2] exceeds the entered CO2Crit\n  \n  k1 <- getK1(t,s)\n  k2 <- getK2(t,s)\n  \n  a <- co2Crit - dic\n  b <- co2Crit * k1\n  c <- co2Crit * k1 * k2\n  \n  discrim <- b^2 - 4*a*c\n  \n  # NB: Want 'negative' of sqrt to insure 'positive' result (denom is negative -- always here?)\n  x <- (-b - sqrt(discrim))/(2*a)\n  \n  return(-log10(x))\n}\n\n\n# calc alkalinity for DIC and pH (FREE)\n# use to trace critical CO2 boundary when supply pH of crit CO2 & DIC\ncalcAlkOfDicPhTempSal <- function(dic,ph,t,s) {\n  \n  alk <- dic * (alphaOne(t,s,ph) + 2 * alphaTwo(t,s,ph))\n  \n  alk <- alk + calcHydroxide(ph,t,s)\n  \n  alk <- alk - calcHydronium(ph)\n  \n  alk <- alk + calcBorate(ph,t,s)\n  \n  return(alk)\n}\n\n\n# calc DIC for a given [Alk] & pH -- COULD USE WHEN pH is pHCrit for CO2Crit, no ???\n# ** What are the units of DIC? Do [Alk] units need converted from \"/liter\" to \"/kg\" ?\ncalcDicOfAlk <- function(alk,ph,t,s) {\n  \n  m <- alphaOne(t,s,ph)\n  \n  m <- m + 2 * alphaTwo(t,s,ph)\n  \n  dic <- (alk - calcHydroxide(ph,t,s) - \n                  calcBorate(ph,t,s) + \n                  calcHydronium(ph)) / m\n  \n  return(dic)\n}\n\n\n#pragma mark - pH of [Alk] & DIC\n# ** NB: Use the secant method to solve the resulting quartic polynomial\ncalcPhForAlkDic <- function(alk,dic,t,s) {\n  \n  # ** assemble the Ki and concentrations...\n  KW <- calcKWMehrbach(t,s)\n  K1 <- getK1(t,s,0.0)\n  K2 <- getK2(t,s,0.0)\n  B  <- calcBorateConcOfSalinity(s)\n  KB <- calcBorateFactor(t,s)\n  \n  # ** calculate the coefficients of the quartic polynomial...\n  q4 <- 1 - KW\n  q3 <- alk - KW*KB + KB - K1*KW + K1\n  q2 <- alk*KB - KB*B + alk*K1 - K1*KW*KB + K1*KB - K1*K2*KW + K1*K2 - dic*K1\n  q1 <- alk*K1*KB - K1*KB*B + alk*K1*K2 - K1*K2*KW*KB + K1*K2*KB - dic*K1*(KB + 2*K2)\n  q0 <- (K1*K2*KB) * (alk - 2*dic - B)\n  \n  thePh <- calcSecantMethod(q4,q3,q2,q1,q0)\n  thePh <- -log10(thePh)\n  \n  return(thePh)\n}\n\n\n# ---- TANCalc methods ----\n\n# calc pH at which un-ionized ammonia becomes unsafe for a given level of TAN\n# from Fivelstad formula\ncalcCritPhTan <- function(tan,unIonized,temp,sal) {\n  \n  temp <- temp - 273.15   # added for R version\n  \n  critPhTan <- 10.0869 + 0.002 * sal - 0.034 * temp\n  critPhTan <- critPhTan - 0.43429448190325182765 * log((tan - unIonized) / unIonized)\n  \n  return(critPhTan)\n}\n\n# calc % un-ionized ammonia according to Fivelstad formula \ncalcUnIonPoStoFivelsted <- function(mypH,temp,sal) {\n  \n  temp <- temp - 273.15   # added for R version\n  \n  unIonPoSto <- 9.242\n  unIonPoSto <- unIonPoSto + 0.002 * sal\n  unIonPoSto <- unIonPoSto + (0.034 * (24.85 - temp) - mypH)\n  unIonPoSto <- 1.0 / (1.0 + 10^unIonPoSto)\n  \n  return(unIonPoSto)\n}\n\n# calc % un-ionized ammonia according to Johansson & Wedborg formula\ncalcUnIonPoStoJohanssonWedborg <- function(mypH,temp,sal) {\n  \n  unIonPoSto <- -0.467\n  unIonPoSto <- unIonPoSto + 0.00113 * sal\n#  unIonPoSto <- unIonPoSto + 2887.9 / (temp + 273.15) # original formulation\n  unIonPoSto <- unIonPoSto + 2887.9 / temp\n  unIonPoSto <- unIonPoSto + -mypH\n  unIonPoSto <- 1.0 / (1.0 + 10^unIonPoSto)\n  \n  return(unIonPoSto)\n}\n\n# TANCalc methods from WQTech 0.95 (xCode project)\n#pragma mark - NH3 & HNO2 calcs\n\n# ** calc the percentage of un-ionized ammonia\n# ** [CHECK] pH on FREE proton scale...Yes\n\n# ** output percentage (same for total ammonia or total ammonia nitrogen)\n# ** and percentage need not be converted to, e.g., the NBS scale, eh?\n# ** double thePercentage = 100.0 / (1.0 + (1.0 / pow(10,-(-log10(kNH4))+pH)));\n\n# ** NB: \"threshold level of 0.025 mg/L (25 μg/L)\n# **     \"Un-ionized Ammonia of 0.05 mg/L (50 μg/L) may harm fish.\n# **     \"As Un-ionized Ammonia approaches 2.0 mg/L (2000 μg/L), fish will begin to die.\"\n\npercentNh3ForTemp <- function(t, s, ph) {\n  \n  pKNH4 <- -log10(getKNH4(t,s,0))\n\n  expOfTen <- pKNH4 - ph\n\n  return(100.0 / (1.0 + 10^expOfTen))\n}\n\n# NB: On the FREE scale\ncritPhFreeForTanMillero <- function(tan, uia, t, s) {\n  \n  # cat('IN critPhFreeForTanMillero, uia = ', uia, ' and sal = ', s, '\\n')\n  \n  return( -log10( (tan/uia) - 1 ) - log10(getKNH4(t, s, 0)))\n}\n\n# ** T-, S-, & pH-dependent K of NH4+ from Millero et al. (1995)\n# ** pH scale: SWS\n# ** concentration scale: mol/kg-soln\ngetKNH4 <- function(t, s, p) {\n  \n  sqrtS <- sqrt(s)\n\n  A <- -0.25444 + 0.46532  * sqrtS - 0.01992 * s\n  B <- -6285.33 - 123.7184 * sqrtS + 3.17556 * s\n  D <- 0.0001635\n\n  KNH4 <- A + (B / t) + D * t\n\n# ** NB: THIS conversion puts it on the FREE pH scale, as per AquaEnv\n# **     factor for sws2free = 1.0 / ahFreeToSwsFactorForSalinity:temp:pressure:\n# **     WHEN DEALING WITH -log10, -log10(1 / ah) = -(-log10(ah)) = +log10(ahFreeToSWSFactor...)\n\n  pKNH4 <- -log10(exp(KNH4))\n\n  pKNH4_FREE <- pKNH4 + log10(ahFreeToSwsFactor(s,t,0.0))\n\n# ** do a calc in terms of NBS scale\n  pKNH4_Nbs <- pKNH4 - log10(ahSwsToNbsFactor(s,t,0.0))\n\n  sf <- (log10(ahFreeToSwsFactor(s,t,0.0)) +\n         log10(ahSwsToNbsFactor(s,t,0.0)))\n\n  pKNH4_Nbs2 <- pKNH4_FREE - sf\n\n  return(10^(-pKNH4_FREE)) # K-NH4\n}\n\n# ---- calc CO3 ----\n\ncalcCO3 <- function(dic,t,s,ph) {\n  \n  carbonate = dic * alphaTwo(t,s,ph)\n  \n  return(carbonate)\n}\n\n# ---- Omega-calcite & -aragonite ----\n\nconvertCaToMolesPerKg <- function(ca,t,s) {\n  \n  caInMolesPerKg <- ca / 40.078\n  caInMolesPerKg <- caInMolesPerKg / calcRho(t,s)\n  \n#  463.0 mg/L => 0.011303558407068858 mol/kg\n  \n  return(caInMolesPerKg)\n}\n  \n\n# ** Compare with Plummer & Busenberg (1982) formula used in Wojtowicz swimming pool\n# ** paper \"A Revised and Updated Saturation Index Equation\",\n# ** J. Swimming Pool & Spa Industry, 3(1):28 - 34\n# ** log(Ks) =  -171.9065 - 0.077993*T + 2839.319/T + 71.595*log(T)\n# ** NB: It's the SAME as calcKspCa(myTemp, 0.00), eh?\n# ** from Mucci (1983)\n# ** concentration scale: mol^2 / kg-soln^2\n\ncalcKspCa <- function(t,s) {\n\n#\tt += 273.15;   # convert from C to K\n\n  omegaCa <- -171.9065\n  omegaCa <- omegaCa + -0.77712 * sqrt(s)\n  omegaCa <- omegaCa + -0.07711 * s\n  omegaCa <- omegaCa +  0.0041249 * s^1.5\n\n  omegaCa <- omegaCa + (2839.319  + 178.34 * sqrt(s)) / t\n\n  omegaCa <- omegaCa + 71.595 * log10(t)\n\n  omegaCa <- omegaCa + (-0.077993 + 0.0028426 * sqrt(s)) * t\n\n  return(10^omegaCa)\n}    \n\ncalcKspAr <- function(t,s) {\n\n#\tt += 273.15;   # convert from C to K\n\n  omegaAr <- -171.945\n  omegaAr <- omegaAr + -0.068393  * sqrt(s)\n  omegaAr <- omegaAr + -0.10018  * s\n  omegaAr <- omegaAr + 0.0059415 * s^1.5\n\n  omegaAr <- omegaAr + (2903.293  + 88.135 * sqrt(s)) / t\n\n  omegaAr <- omegaAr + 71.595 * log10(t)\n\n  omegaAr <- omegaAr + (-0.077993 + 0.0017276 * sqrt(s)) * t\n\n  return(10^omegaAr)\n}\n\n\ncalcOmegaCa <- function(dic,ca,t,s,ph) {\n  \n  result <- ca * calcCO3(dic,t,s,ph)\n  \n  result <- result / calcKspCa(t,s)\n  \n  return(result)\n}\n\ncalcOmegaAr <- function(dic,ca,t,s,ph) {\n  \n  result <- ca * calcCO3(dic,t,s,ph)\n  \n  result <- result / calcKspAr(t,s)\n  \n  return(result);\n}\n\n\n# ---- Langelier ----\n\n# ** put pK values on NBS scale\n# ** input as K values, convert to pK values\nconvertFreeToNbsForLangelier <- function(k2,kspca,kspar,t,s,p) {\n  \n  sf <- log10(ahFreeToSwsFactor(s,t,p)) + \n        log10(ahSwsToNbsFactor(s,t,p))\n  \n  return(c(-log10(k2)-sf,-log10(kspca)-sf,-log10(kspar)-sf))\n}\n\n# ** [NEW--**CORRECTED**] to calc CALCITE saturation pH\ncalcPhSatForOmegaCa <- function(omega,alk,ca,t,s,p) {\n  \n  K1  <- getK1(t,s,p)\n  K2  <- getK2(t,s,p)\n  Kw  <- calcKWMehrbach(t,s)\n  Ksp <- calcKspCa(t,s)\n  B   <- calcBorateConcOfSalinity(s)\n  KB  <- calcBorateFactor(t,s)\n  omf <- omega*Ksp/ca;\n  \n  # ** 0.01028 mol/kg-soln @ 19.374C & 35 psu,\n  # ** Riley & Tongudai (1967)\n  \n  # ** Implement the secant algorithm\n  q4 <- 0.0\n  q3 <- K1*(K2-omf)\n  q2 <- K1*(K2*(alk+KB)-omf*(KB+2*K2))\n  q1 <- K1*K2*(KB*(alk-B-2*omf)-Kw)\n  q0 <- K1*K2*(-Kw*KB)\n  \n  thePh <- calcSecantMethod(q4,q3,q2,q1,q0)\n  thePh <- -log10(thePh)\n    \n  return(thePh)\n}\n\n\n# ---- Conductivity to Salinity ----\n\nconductivityToSalinity <- function(c, t, p, unitsIn, unitsOut) {\n  \n  # ** 0. convert input units to ICU, S/m\n  if(unitsIn != 'S/m')\n    c <- c * conductivityToIcUFactor(unitsIn, 'S/m')\n  \n  myConductivity <- 4.2914  # ** S/m\n  \n  # ** 1. calculate conductivity ratio R\n  myR <- c / myConductivity\n  \n  # ** 2. calculate rsubt -- function of temperature\n  c0 <-  0.6766097\n  c1 <-  0.0200564\n  c2 <-  0.0001104259\n  c3 <- -0.00000069698\n  c4 <-  0.0000000010031\n  \n  rSubT <- c0 + c1*t + c2*t*t + c3*t*t*t + c4*t*t*t*t\n  \n  # ** 3. calculate Rsubp -- function of pressure\n  e0 <-  0.00002070\n  e1 <- -0.0000000006370\n  e2 <-  0.000000000000003989\n  d1 <-  0.03426\n  d2 <-  0.0004464\n  d3 <-  0.4215\n  d4 <- -0.003107\n  \n  RsubP <- 1 + p * (e0 + e1*p + e2*p*p) / (1 + d1*t + d2*t*t + (d3 + d4)* myR)\n  \n  # ** 4. calclate RsubT\n  RsubT <- myR / (rSubT * RsubP)\n  \n  # ** 5. calculate S'\n  k  <-  0.0162\n  b0 <-  0.0005\n  b1 <- -0.0056\n  b2 <- -0.0066\n  b3 <- -0.0375\n  b4 <-  0.0636\n  b5 <- -0.0144\n  \n  Sprime <- (t - 15) / (1 + k * (t - 15))\n  \n  Sprime <- Sprime * (b0 + b1*sqrt(RsubT) + b2*RsubT + b3*RsubT^1.5 + b4*RsubT*RsubT + b5*RsubT^2.5)\n  \n  # ** 6. finish it off to calc salinity\n  a0 <-  0.0080\n  a1 <- -0.1692\n  a2 <- 25.385\n  a3 <- 14.0941\n  a4 <- -7.0261\n  a5 <-  2.7081\n  \n  mySal <- a0 + a1*sqrt(RsubT) + a2*RsubT + a3*RsubT^1.5 + a4*RsubT*RsubT + a5*RsubT^2.5 + Sprime\n  \n  # ** 7. return salinity in ppt\n  return(mySal)\n}\n\nconductivityToIcUFactor <- function(inUnits, outUnits) {\n  \n  # convert inUnits to IC Units\n  if(inUnits == 'μS/cm')\n    return(0.0001)\n  else if(inUnits == 'mS/cm')\n    return(0.1)\n  else\n    return(1.0)\n}\n",
    "created" : 1472560917371.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "672072296",
    "id" : "2D79034E",
    "lastKnownWriteTime" : 1472397578,
    "last_content_update" : 1472397578,
    "path" : "~/R Projects/WQ iQuaCalc Lite/CarbCalc.R",
    "project_path" : "CarbCalc.R",
    "properties" : {
        "docOutlineVisible" : "0"
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}