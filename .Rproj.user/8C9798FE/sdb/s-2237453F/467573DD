{
    "collab_server" : "",
    "contents" : "# server script for iQuaCalc (Lite)\n\n# NB: for iQuaCalc (Lite), using only conversion functions\n# so renamed as converter.R\n# load script for unit conversions\nsource('serverHelper.R')\nsource('converter.R')\n\nlibrary(dplyr)         # NB: Is this installed on {shiny} server?\nlibrary(ggplot2)       # NB: Is this installed on {shiny} server?\nlibrary(shinyjs) \n\n\n\nfunction(input, output, session) {\n  \n    \n  # TEMPORARILY DIS-able salinity selectInput (see bodyHTML.R / ammoniaStuff and useShinyjs())\n  shinyjs::disable('salUnits')\n  \n  \n    \n# observer -- persist ** LENGTH ** CONVERSION radio button state\n  observe({\n    \n    # get index of previous radio button selection (initialized as 'L1')\n    # (this determines numericInput entry & selectInput selection)\n    lastRbIdx_lengthConvertH <- which(radButtonVector_lengthConvert == lastRadButtonL)\n    \n    # persist last entry of previous radio button selection\n    numericInput_lengthConvertH[lastRbIdx_lengthConvertH] <<- isolate(currentLengthH())\n    \n    numericInput_feetConvertH[lastRbIdx_lengthConvertH] <<- isolate(input$feetConvertH)\n    numericInput_inchConvertH[lastRbIdx_lengthConvertH] <<- isolate(input$inchConvertH)\n    \n    \n    # get index of current radio button selection\n    currentRbIdx_lengthConvertH <- which(radButtonVector_lengthConvert == input$radLengthH)\n    \n    # get persisted VALUE of current radio button selection\n    # update numericInput with value persisted for current radio button selection\n    updateNumericInput(session, \n                       # inputId = 'lengthConvertH',\n                       inputId = 'lengthInputH',\n                       label = input$lengthUnitsH,\n                       value = numericInput_lengthConvertH[currentRbIdx_lengthConvertH],\n                       step = 0.1)\n    \n    updateNumericInput(session, \n                       inputId = 'feetConvertH',\n                       label = 'feet',\n                       value = numericInput_feetConvertH[currentRbIdx_lengthConvertH],\n                       step = 1)\n    \n    updateNumericInput(session, \n                       inputId = 'inchConvertH',\n                       label = 'inch',\n                       value = numericInput_inchConvertH[currentRbIdx_lengthConvertH],\n                       step = 1)\n    \n    # ---- Deal with FRACTIONAL SELECTION INPUT ----\n    \n    # persist last entry of FRACTIONAL INCH selection\n    selectionChoice_fractInchConvertH[lastRbIdx_lengthConvertH] <<- isolate(input$fractionalInchConvertUnitsH)\n    updateSelectInput(session, \n                      inputId = 'fractionalInchConvertUnitsH', \n                      selected = selectionChoice_fractInchConvertH[currentRbIdx_lengthConvertH])\n    \n    \n    # ---- Deal with UNITS SELECTION INPUT ----\n    selectionChoice_lengthConvertH[lastRbIdx_lengthConvertH] <<- isolate(input$lengthUnitsH)\n    \n    updateSelectInput(session, \n                      inputId = 'lengthUnitsH', \n                      selected = selectionChoice_lengthConvertH[currentRbIdx_lengthConvertH])\n    \n    # re-assign last radio button selection\n    lastRadButtonL <<- input$radLengthH\n    \n  })\n  \n  \n  # observer -- persist ** VOLUME ** CONVERSION radio button state\n  observe({\n    \n    # get index of previous radio button selection (initialized as 'L1')\n    # (this determines numericInput entry & selectInput selection)\n    lastRbIdx_volumeConvertH <- which(radButtonVector_volumeConvert == lastRadButtonVol)\n    \n    # persist last entry of previous radio button selection\n    numericInput_volumeConvertH[lastRbIdx_volumeConvertH] <<- isolate(currentVolumeH())\n    \n    \n    # get index of current radio button selection\n    currentRbIdx_volumeConvertH <- which(radButtonVector_volumeConvert == input$radVolumeH)\n    \n    # get persisted VALUE of current radio button selection\n    # update numericInput with value persisted for current radio button selection\n    updateNumericInput(session, \n                       inputId = 'volumeInputH',\n                       label = input$volumeUnitsH,\n                       value = numericInput_volumeConvertH[currentRbIdx_volumeConvertH],\n                       step = 0.1)\n    \n    \n    # ---- Deal with UNITS SELECTION INPUT ----\n    selectionChoice_volumeConvertH[lastRbIdx_volumeConvertH] <<- isolate(input$volumeUnitsH)\n    \n    updateSelectInput(session, \n                      inputId = 'volumeUnitsH', \n                      selected = selectionChoice_volumeConvertH[currentRbIdx_volumeConvertH])\n    \n    # re-assign last radio button selection\n    lastRadButtonVol <<- input$radVolumeH\n    \n  })\n  \n  \n# observer -- ** AREA x DEPTH = VOLUME ** CONVERSION\n  \n  formula.AxD <- function(area, depth, volume) {\n    \n    my.formula <<- paste0('(', area, ') x (', depth, ') = ', volume)\n    output$formulaAxD <- renderText(my.formula)\n  }\n  \n  \n  observeEvent(c(currentUnitsAxD(), input$volumeInputAxD, \n                 input$feetConvertAxD, input$inchConvertAxD, \n                 input$fractionalInchConvertUnitsAxD),\n    {\n      # print('>>>>>>>> In observeEvent(currentUnitsAxD()...')\n      \n      current.rb <- radAxD()\n      current.value <- input$volumeInputAxD\n      current.units <- currentUnitsAxD()\n      \n      if(current.rb == 1)\n        area <<- paste(current.value, current.units)\n      else {\n        if(current.units != 'yards')\n          depth <<- paste(current.value, current.units)\n        else {\n          \n          # NB: must present current.value in 'yards' as yds/ft/in/fractional inches\n          depth <<- paste0(current.value, ' yd  ', \n                          input$feetConvertAxD, ' ft  ', \n                          input$inchConvertAxD, ' ', input$fractionalInchConvertUnitsAxD, ' in')\n        }\n      }\n      \n      formula.AxD(area, depth, volume)\n      \n      # print('AAAAA')\n      selectColumns(proxy, 2)\n    }\n  )\n  \n  observe({\n    \n    current.rb <- radAxD()\n    # current.value <- input$volumeInputAxD\n    current.value <- currentValueAxD()\n    current.units <- currentUnitsAxD()\n    \n    # get index of previous radio button selection ('Area' or 'Depth')\n    # (this determines numericInput entry & selectInput selection)\n    lastRbIdx_volumeAxD <- which(radButtonVector_volumeAxD == lastRadButtonVolAxD)\n    \n    # get index of current radio button selection\n    # currentRbIdx_volumeAxD <- which(radButtonVector_volumeAxD == input$volumeRadAxD)\n    currentRbIdx_volumeAxD <- which(radButtonVector_volumeAxD == radButtonVector_volumeAxD[current.rb])\n    \n    # ************ NB: OK or NO?? *************\n    # persist last entry of previous radio button selection\n    # numericInput_volumeAxD[lastRbIdx_volumeAxD] <<- isolate(currentValueAxD())\n    numericInput_volumeAxD[lastRbIdx_volumeAxD] <<- current.value\n    \n    numericInput_feetConvertAxD <<- input$feetConvertAxD\n    numericInput_inchConvertAxD <<- input$inchConvertAxD\n    \n    # get persisted VALUE of current radio button selection\n    # update numericInput with value persisted for current radio button selection\n    \n    # print('in OBSERVE...')\n    # print(numericInput_volumeAxD)\n    # cat('                          input$feetConvertAxD:', input$feetConvertAxD, '\\n')\n    # cat('                        currentRbIdx_volumeAxD:', currentRbIdx_volumeAxD, '\\n')\n    # cat('            numericInput_volumeAxD[current.rb]:', numericInput_volumeAxD[current.rb], '\\n')\n    # cat('numericInput_volumeAxD[currentRbIdx_volumeAxD]:', numericInput_volumeAxD[currentRbIdx_volumeAxD], '\\n\\n')\n    \n    updateNumericInput(session, \n                       inputId = 'volumeInputAxD',\n                       label = current.units,\n                       value = numericInput_volumeAxD[currentRbIdx_volumeAxD],\n                       step = 0.1)\n    \n    updateNumericInput(session, \n                       inputId = 'feetConvertAxD',\n                       label = 'feet',\n                       value = numericInput_feetConvertAxD,\n                       step = 1)\n    \n    updateNumericInput(session, \n                       inputId = 'inchConvertAxD',\n                       label = 'inch',\n                       value = numericInput_inchConvertAxD,\n                       step = 1)\n    \n    # ---- Deal with FRACTIONAL SELECTION INPUT ----\n    \n    # persist last entry of FRACTIONAL INCH selection\n    # selectionChoice_fractInchConvertAxD<<- isolate(input$fractionalInchConvertUnitsAxD)\n    selectionChoice_fractInchConvertAxD<<- input$fractionalInchConvertUnitsAxD\n    updateSelectInput(session, \n                      inputId = 'fractionalInchConvertUnitsAxD', \n                      selected = selectionChoice_fractInchConvertAxD)\n    \n    \n    # ---- Deal with UNITS SELECTION INPUT ----\n    # NB: CORRECTLY UPDATE SELECTION CHOICE???\n    # lastRbIdx_volumeAxD and different length choices in Area and Depts\n    \n    updateSelectInput(session, \n                      inputId = 'volumeSelectAxD', \n                      label = radButtonVector_volumeAxD[current.rb],\n                      choices = areaOrDepthUnitsChoices[[currentRbIdx_volumeAxD]]$units,\n                      selected = current.units)\n    \n    \n    # ---- UPDATE FORMULA HERE...\n#     area <<- paste(current.value, current.units)\n#     my.formula <- paste('yadda-yadda...', area, 'x', depth)\n#     output$formulaAxD <- renderText(my.formula)\n    \n    \n    # re-assign last radio button selection\n    lastRadButtonVolAxD <<- radButtonVector_volumeAxD[current.rb]\n    \n  })\n  \n  \n  \n# observer -- persist TANK radio button state\n  observe({\n    \n    # get the index of the previous radio button selection (initialized as 'radius')\n    # (this determines the numericInput entry & the selectInput selection)\n    lastRadButtonIdx <- which(radButtonVector_circular == lastRadButton)\n    \n    # persist last entered value of previous radio button selection \n    # numericInputValues[lastRadButtonIdx] <<- isolate(currentLengthTank())\n    numericInputValues[lastRadButtonIdx] <<- isolate(input$metersOrYards)\n    \n    # get the index of the current radio button selection\n    currentRadButtonIdx <- which(radButtonVector_circular == input$circular)\n    \n    # get the persisted VALUE of the current radio button selection\n    # update value of numericInput with value persisted for current radio button selection\n    updateNumericInput(session, \n                       inputId = 'metersOrYards', \n                       label = input$tankUnits,\n                       value = numericInputValues[currentRadButtonIdx],\n                       step = 0.1)\n                       # step = 5)\n    #     updateNumericInput(session, \n    #                        inputId = 'metersTank', \n    #                        value = numericInputValues[currentRadButtonIdx])\n    \n    # ---- Deal with SELECTION INPUT ----\n    selectionChoiceValues[lastRadButtonIdx] <<- isolate(input$tankUnits)\n    \n    updateSelectInput(session, \n                      inputId = 'tankUnits', \n                      selected = selectionChoiceValues[currentRadButtonIdx])\n    \n    # re-assign last radio button selection\n    lastRadButton <<- input$circular\n    \n  })\n  \n  # ---- I.C. Units as reactive expressions ----\n  \n  volDisinfectantToAdd <- reactive ({\n    # volume to add in ml/L\n    volInMlPerL <- input$ppmSlider / (10 * input$poStoSlider)\n    \n    # cat('*********************\\n')\n    # total volume of tank in liters\n    #     totalToDisinfectInLiters <- convertVol(input$totVolToDisinfect,\n    #                                            input$disinfectUnitsTot,\n    #                                            'liters (L)')\n    # #     \n    #     totDisinfectantToAdd <- convertVol(totalToDisinfectInLiters * volInMlPerL,\n    #                                        'milliliters (ml)',\n    #                                        input$disinfectUnitsToAdd)\n    \n    # converted <- convertAll(my.liters, my.input.volume, vol.data)\n    \n    # -------------------------------------------------\n    \n    # calculate L (I.C. units) to add\n    totalToDisinfectInLiters <- convert(input$totVolToDisinfect,\n                                        input$disinfectUnitsTot,\n                                        'liters (L)', vol.data)\n\n    # convert total mL to add to selected volume units to add\n    totDisinfectantToAdd <- convert(totalToDisinfectInLiters * volInMlPerL,\n                                    'milliliters (ml)',\n                                    input$disinfectUnitsToAdd, vol.data)\n    \n    # cat('             volInMlPerL: ',volInMlPerL, '\\n')\n    # cat(' new convert (volume US): ',convert(1.0, 'gallons (US)', 'liters (L)', vol.data), '\\n')\n    # cat(' new convert (volume UK): ',convert(1.0, 'gallons (UK)', 'liters (L)', vol.data), '\\n')\n    # cat('   new convert (flow):',convert(1.0, 'm³/d', 'acre-ft/d', flow), '\\n')\n    # cat('   new convert (area):',convert(1.0, 'ha', 'm²', area.data), '\\n')\n    # cat('   new convert (area):',convert(1.0, 'ha', 'acre', area.data), '\\n')\n    \n    # x <- convertAll(1.0, 'acre-ft/d', flow)\n    # print(x)\n    \n    #     cat('totalToDisinfectInLiters:',totalToDisinfectInLiters,'\\n')\n    #     cat('    totDisinfectantToAdd:',totDisinfectantToAdd,input$disinfectUnitsToAdd,'\\n')\n    \n    # convertedFlowRate <- convertFlowRate(1.0, 'm³/d', 'liter/d')\n    \n    # cat('*********************\\n')\n    totDisinfectantToAdd\n  })\n  \n  \n# ---- icTemp & icSal ----\n  \n  icTemp <- reactive ({\n    \n    # cat(' input$tempUnits ', input$tempUnits, '\\n')\n    # cat('input$tempSlider ', input$tempSlider, '\\n')\n    \n    idx <- which(input$tempUnits == tempUnitsList)\n    tempToIcUnits(input$tempSlider, idx)\n  })\n  \n  icSal <- reactive ({\n    \n    # if(is.null(icTemp())) {\n    #   cat('icTemp() is NULL\\n')\n    #   temp <- initValues$t\n    # } else {\n    #   temp <- icTemp()\n    # }\n    # cat('input$salSlider ', input$salSlider, '\\n')\n    # cat(' input$salUnits ', input$salUnits, '\\n')\n    \n    idx <- which(input$salUnits == salUnitsList)\n    # salToIcUnits(input$salSlider, idx, icTemp(), 0)\n  })\n  \n  icTanVal <- reactive ({\n    # idx <- which(input$salUnits == salUnitsList)\n    # salToIcUnits(input$salSlider, idx, icTemp(), 0)\n    \n    input$tanVal\n  })\n  \n  \n  # ---- TANK DIMENSION TabsetPanel ----\n  \n  tankDimensionsPanels <- reactive({\n    \n    # get current entry in first (mm, cm, m, or yards) field\n    # x <- currentLengthTank()\n    x <- input$metersOrYards\n    \n    # convert entered datum to I.C. units -- meters\n    if(input$tankUnits == 'yards') {\n      \n      # my.meters <- convertYdFtAndInchesToMeters(currentLengthTank(),\n      my.meters <- convertYdFtAndInchesToMeters(input$metersOrYards,\n                                                input$feetConvertTank,\n                                                input$inchConvertTank,\n                                                input$fractionalInchesTank)\n      \n      # [KLUDGE] for imprecision...\n      x.in.ic.units <- round(my.meters, 8)\n      \n    } else {\n      \n      # convert that entry to IC units (meters)\n      x.in.ic.units <- convert(x, input$tankUnits, length.data[3], length.data)\n      \n    }\n    \n    \n    if(input$tankPanels == 'Circular Tank') {\n      # print('in CIRCULAR TANK...')\n      # print(input$circular)\n      if(input$circular == 'radius') {\n        # print('in CIRCULAR TANK RADIUS...')\n        mySquareFactor <<- x.in.ic.units ^ 2\n        formulaAreaCircle <<- paste(as.character(x), input$tankUnits)\n        \n      } else if(input$circular == 'diameter') {\n        # print('in CIRCULAR TANK DIAMETER')\n        mySquareFactor <<- (x.in.ic.units / 2) ^ 2\n        formulaAreaCircle <<- paste(as.character(x), '/ 2', input$tankUnits)\n        \n      } else {    # entered depth\n        # print('in CIRCULAR TANK DEPTH')\n        my.depth <<- x.in.ic.units\n        formulaDepthCircle <<- paste(as.character(x), input$tankUnits)\n        \n      }\n      \n      circle.formula <- paste('Volume Circle: π x (',\n                              formulaAreaCircle, ')\\U00B2 x (', \n                              formulaDepthCircle, ')')\n      formulaAreaVolume <<- circle.formula\n      \n      my.area <- pi * mySquareFactor\n      my.volume <- my.area * my.depth * 1000    # multiply by 1000 from m3 -> L (vol I.C. units)\n      \n    } else if(input$tankPanels == 'Rectangular Tank') {\n      \n      if(input$rectangular == 'length') {\n        \n        l <<- x.in.ic.units\n        my.length <- convertAll(l, length.data[3], length.data)\n        formulaRectangleLength <<- paste(as.character(x), input$tankUnits)\n        \n      } else if(input$rectangular == 'width') {\n        \n        w <<- x.in.ic.units\n        my.width <- convertAll(w, length.data[3], length.data)\n        formulaRectangleWidth <<- paste(as.character(x), input$tankUnits)\n        \n      } else if(input$rectangular == 'shallow-end depth') {\n        \n        d.s <<- x.in.ic.units\n        my.depth.s <- convertAll(d.s, length.data[3], length.data)\n        formulaRectangleDepthSmall <<- paste(as.character(x), input$tankUnits)\n        \n      } else {\n        \n        d.d <<- x.in.ic.units\n        my.depth.d <- convertAll(d.d, length.data[3], length.data)\n        formulaRectangleDepthLarge <<- paste(as.character(x), input$tankUnits)\n        \n      }\n      \n      rectangle.formula <- paste('Formula: (',\n                                 formulaRectangleLength, ') x (', \n                                 formulaRectangleWidth, ') x (',\n                                 formulaRectangleDepthSmall, ')')\n      formulaAreaVolume <<- rectangle.formula\n      \n      my.area <- l * w\n      my.volume <- (my.area * d.s) * 1000    # divide by 1000 from m3 -> L (vol I.C. units)\n      \n      \n    } else {\n      my.area <- 1.0\n    }\n    \n    my.tank.table <- convertAll(my.area, 'm²', area)\n    \n    # polish AREA output for clean display of very large/small values\n    my.tank.table <- my.tank.table %>% \n      mutate(rounded.area = ifelse(values < 0.0001 | values > 100000,\n                                   format(values, digits = 4, scientific = T),\n                                   ifelse(values > 0.1,\n                                          format(round(values, 3), digits = 3, scientific = F),\n                                          format(round(values, 6), digits = 4, scientific = F)\n                                   )\n      )\n      )\n    \n    # used dplyr to rearrange area data from \"ha\"  & \"4.345\" to \"4.345 ha\"\n    # c(\"ha\",\"m²\",\"cm²\",\"mm²\",\"acre\",\"ft & in\",\"yd²\",\"ft²\",\"in²\")\n    # c(\"D\",\"A\",\"F\",\"G\",\"E\",\"I\",\"C\",\"B\",\"H\")\n    my.tank.table$order <- c(\"D\",\"A\",\"F\",\"G\",\"E\",\"I\",\"C\",\"B\",\"H\")\n    \n    my.tank.table <- my.tank.table %>% \n      mutate('area' = paste(rounded.area, units)) %>%\n      arrange(order) %>% \n      filter(units %in% c('m²', 'ft²', 'yd²', 'ha', 'acre')) %>% \n      select(area)\n    \n    # c('milliliters (ml)', 'liters (L)', 'cubic meters (m\\U00B3)',\n    #   'gallons (US)', 'gallons (UK)', 'acre-ft')\n    # c(\"F\",\"D\",\"A\",\"B\",\"C\",\"E\")\n    my.tank.volume <- convertAll(my.volume, 'liters (L)', vol)\n    \n    # polish volume output for clean display of very large/small values\n    my.tank.volume <- my.tank.volume %>% \n      mutate(rounded.volume = ifelse(values < 0.0001 | values > 100000,\n                                     format(values, digits = 4, scientific = T),\n                                     ifelse(values > 0.1,\n                                            format(round(values, 3), digits = 3, scientific = F),\n                                            format(round(values, 6), digits = 4, scientific = F)\n                                     )\n      )\n      )\n    \n    \n    my.tank.volume$order <- c(\"F\",\"D\",\"A\",\"B\",\"C\",\"E\")\n    my.tank.volume$display.units <- c('ml', 'L', 'm\\U00B3', 'gal (US)', 'gal (UK)', 'acre-ft')\n    my.tank.volume <- my.tank.volume %>% \n      mutate('volume' = paste(rounded.volume, display.units)) %>% \n      arrange(order) %>% \n      filter(display.units %in% c('m\\U00B3', 'gal (US)', 'gal (UK)', \n                                  'acre-ft', 'L')) %>% \n      select(volume)\n    \n    # left_join or...column_join?\n    \n    my.tank.table <- my.tank.table %>% bind_cols(my.tank.volume)\n    \n    tank.data.packet <- list(table = my.tank.table,\n                             formula = formulaAreaVolume)\n    \n    tank.data.packet\n    \n  })\n  \n  tankDimensionDatatable <- reactive({\n    \n    df <- tankDimensionsPanels()$table\n    format(df, digits = 6, scientific = F)\n    \n  })\n  \n  tankDimensionFormula <- reactive({\n    my.formula <- tankDimensionsPanels()$formula\n    my.formula\n  })\n  \n  # ---- renderUI tank dimensions ----\n  \n  #   output$metersTankUI <- renderUI({\n  #     \n  #     # logic for computing and placing tank dimensions\n  #     tankDimensionsPanels()\n  #     \n  #     if(!is.null(input$tankUnits)) {\n  #       cat('in output$metersTankUI...\\n')\n  # #       cat('    input$tankUnits:', input$tankUnits, '\\n')\n  #       # cat('currentLengthTank():', currentLengthTank(), '\\n')\n  # #       cat('  stepFtAndInTank():', stepFtAndInTank(), '\\n')\n  #       numericInput('metersTank', input$tankUnits,\n  #                    # isolate(currentLengthTank()), 0, 1000, stepFtAndInTank())\n  #                    isolate(input$metersOrYards), 0, 1000, stepFtAndInTank())\n  #     }\n  #     \n  #   })\n  \n  \n  # render L x W x D formula for tank dimensions\n  # output$whatTimesWhat_samocha <- renderText(\n  #   tankDimensionFormula()\n  # )\n  output$whatTimesWhat_rectangular <- renderText(\n    tankDimensionFormula()\n  )\n  output$whatTimesWhat_circular <- renderText(\n    tankDimensionFormula()\n  )\n  \n  # output$tankSamochaConversionTable <- DT::renderDataTable(\n  #   \n  #   tankDimensionDatatable(),\n  #   rownames = F,\n  #   options = list(dom = 't', 'bSort' = F)\n  # )\n  \n  output$tankRectangularConversionTable <- DT::renderDataTable(\n    \n    tankDimensionDatatable(),\n    rownames = F,\n    options = list(dom = 't', 'bSort' = F)\n  )\n  \n  output$tankCircularConversionTable <- DT::renderDataTable(\n    \n    tankDimensionDatatable(),\n    # tankDimensionsPanels(),\n    rownames = F,\n    options = list(dom = 't', 'bSort' = F)\n  )\n  \n  \n  # ---- renderUI Length FT & IN ----\n  \n# persists current length input\n# isolated in re-rendering lengthConvert numericInput in output$lengthConvert <- renderUI...\n  currentLength_2 <- reactive({\n    \n    if(is.null(input$lengthInput_2))\n      lengthToConvert\n    else\n      if(input$lengthUnits_2 == 'yards')\n        floor(input$lengthInput_2)\n    else\n      input$lengthInput_2\n  })\n  \n# capture change of input length conversion units to change...\n#   * step parameter of selectInput (0 for whole English units, 0.1 for all metric units)\n#   * conversion function in converter.R to calculate data.frame of results\n  stepFtAndIn_2 <- reactive({\n    \n    if(input$lengthUnits_2 == 'yards') {\n      # convertFtAndInchesToMeters(0, 1, 0)\n      mystep_2 <- 0\n    } else {\n      mystep_2 <- 0.1\n    }\n  })\n  \n  # render LENGTH INPUT VALUE\n  # output$echoLengthInput <- renderText(\n  output$echoLengthInput <- renderUI(\n    # lengthFormulaPanel()\n    if(input$lengthUnits_2 == 'yards') {\n      \n      fracIn  <- ifelse('0' == input$fractionalInchConvertUnits_2, '', input$fractionalInchConvertUnits_2)\n      wholeIn <- ifelse('0' == input$inchConvert_2 & '0' != fracIn, '', input$inchConvert_2)\n      wholeIn <- ifelse('0' == input$inchConvert_2 & '0' == fracIn, '0', input$inchConvert_2)\n\n# NB: {shiny} HTML collapsing white space??\n# see: http://stackoverflow.com/questions/28878616/r-shiny-htmloutput-removes-white-spaces-i-need/28881850\n# see: http://stackoverflow.com/questions/18205080/shiny-html-output-object-that-takes-html-code-for-easy-copy-and-paste\n\n      yds <- input$lengthInput_2\n      ft  <- input$feetConvert_2\n      \n      # compose inches with correct spacing(s)...\n      \n      \n      tags$code(\n        HTML('<h2><b>Convert: ', yds, 'yd   ', \n             ft, '\\'   ', \n             wholeIn, '', fracIn, '\"')\n      )\n      \n    } else {\n      \n      value <- input$lengthInput_2\n      units <- input$lengthUnits_2\n      \n      tags$code(\n        HTML('<h2><b>Convert: ', value, ' ', units)\n      )\n    }\n  )\n  \n  lengthResults_2 <- reactive({\n    \n    if(input$lengthUnits_2 == 'yards') {\n      \n      my.meters <- convertYdFtAndInchesToMeters(currentLength_2(),\n                                                input$feetConvert_2,\n                                                input$inchConvert_2,\n                                                input$fractionalInchConvertUnits_2)\n      \n      # [KLUDGE] for imprecision...\n      my.meters <- round(my.meters, 8)\n      # my.meters[8] <- round(my.meters[8], 3)\n      \n      # see: http://stackoverflow.com/questions/2227734/in-r-what-is-the-difference-between-these-two?lq=1\n      # my.meters.2 <- sprintf(\"%.54f\",my.meters)\n      \n      my.input.length <- 'm'\n      # convertAll(my.meters, 'm', length.data)\n      \n    } else {\n      \n      my.meters <- currentLength_2()\n      my.input.length <- input$lengthUnits_2\n      # convertAll(currentLength_2(), input$lengthUnits_2, length.data)\n    }\n    \n    converted <- convertAll(my.meters, my.input.length, length.data)\n    \n    nums <- as.numeric(converted$values)\n    \n    #     # round converted values as appropriate\n    converted$values[-c(4:5)] <- signif(nums[-c(4:5)], 4)\n    \n    converted\n    \n  })\n  \n  output$lengthConvert_2 <- renderUI({\n    \n    numericInput('lengthInput_2', input$lengthUnits_2,\n                 isolate(currentLength_2()), 0, 1000, stepFtAndIn_2())\n    # isolate(input$lengthConvert), 0, 1000, stepFtAndIn())\n    \n  })\n  \n  \n  # most input$lengthConvertUnits require 1 and only 1 value (e.g., m, cm, mm),\n  # but to convert FROM \"yd, ft, & in\", require 4:\n  #              whole yd, whole ft, whole in, & fractional inches\n  # so...modify first formal param of convertAll to be a vector?\n  #   ...or add 3 default params = 0? (remember that that is NULL, not an empty list in Python?)\n  \n  output$lengthTable_2 <- DT::renderDataTable(\n    \n    lengthResults_2(),\n    rownames = F,\n    options = list(dom = 't', 'bSort' = F)\n  )\n  \n  \n\n# ---- 'HORIZ' LENGTH INPUT ----\n  \n  # persists current length input\n  # isolated in re-rendering lengthConvert numericInput in output$lengthConvert <- renderUI...\n  currentLengthH <- reactive({\n    \n    if(is.null(input$lengthInputH))\n      lengthToConvert\n    else\n      if(input$lengthUnitsH == 'yards')\n        floor(input$lengthInputH)\n    else\n      input$lengthInputH\n  })\n  \n  # capture change of input length conversion units to change...\n  #   * step parameter of selectInput (0 for whole English units, 0.1 for all metric units)\n  #   * conversion function in converter.R to calculate data.frame of results\n  stepFtAndIn <- reactive({\n    \n    if(input$lengthUnitsH == 'yards') {\n      # convertFtAndInchesToMeters(0, 1, 0)\n      mystep <- 0\n    } else {\n      mystep <- 0.1\n    }\n  })\n  \n  \n# already a reactive function; modify to combine 2 (or more) conversion calculations\n# into one data set such that L.1 + L.2 = (L.1 + L.2)\n# must initialize both(?) and isolate() each conversion result(??)\n#\n# each conversion is associated with a radio button selection, L.1 or L.2\n# maybe a new reactive function that calls lengthResults() and assigns the\n# result based on the radio button selection...?\n  \n  lengthResults <- reactive({\n    \n    if(input$lengthUnitsH == 'yards') {\n      \n      my.meters <- convertYdFtAndInchesToMeters(currentLengthH(),\n                                                input$feetConvertH,\n                                                input$inchConvertH,\n                                                input$fractionalInchConvertUnitsH)\n      \n      # [KLUDGE] for imprecision...\n      my.meters <- round(my.meters, 8)\n      # my.meters[8] <- round(my.meters[8], 3)\n      \n      # see: http://stackoverflow.com/questions/2227734/in-r-what-is-the-difference-between-these-two?lq=1\n      # my.meters.2 <- sprintf(\"%.54f\",my.meters)\n      \n      my.input.length <- 'm'\n      # convertAll(my.meters, 'm', length.data)\n      \n    } else {\n      \n      my.meters <- currentLengthH()\n      my.input.length <- input$lengthUnitsH\n    }\n    \n    converted <- convertAll(my.meters, my.input.length, length.data)\n    \n    nums <- as.numeric(converted$values)\n    \n# use a hidden column to aid in highlighting the cell in which the user enters a datum to convert\n# each element of the hidden column, save one, is '0';\n# the INDEX of the only non-zero element holds a '1' and is the same index as\n# the row of the 'units' column that contains the current input$lengthUnitsH reactive variable\n    # col.hidden <- c(0, 0, 0, 0, 0, 0, 0, 0)\n    oldConvertedLengths$hidden <- c(0, 0, 0, 0, 0, 0, 0, 0)\n\n    cell.idx <- which(lengthUnitsChoices == input$lengthUnitsH)\n\n    # col.hidden[cell.idx] <- 1\n    oldConvertedLengths$hidden[cell.idx] <- 1\n    \n    # [KLUDGE] highlight both 'yd-ft-in' and 'ft-in'\n    if(cell.idx == 4 | cell.idx == 5) {\n      oldConvertedLengths$hidden[4] <- 1\n      oldConvertedLengths$hidden[5] <- 1\n    }\n\n    \n    # round converted values as appropriate\n    converted$values[-c(4:5)] <- signif(nums[-c(4:5)], 4)\n    \n    if(isolate(input$radLengthH) == 'Length 1') {\n      oldConvertedLengths$'Length 1' <- converted$values\n    } else {\n      oldConvertedLengths$'Length 2' <- converted$values\n    }\n    \n    \n    # calculate SUM, based on meters\n    idx.ic.length <- which(length.data$units == length.data$icUnits)\n    sum.meters <- as.numeric(oldConvertedLengths$'Length 1'[idx.ic.length]) + \n      as.numeric(oldConvertedLengths$'Length 2'[idx.ic.length])\n    sums <- convertAll(sum.meters, length.data$icUnits, length.data)\n    \n    # assign sum to display df\n    oldConvertedLengths$Sum <- sums$values\n    \n    oldConvertedLengths <<- oldConvertedLengths\n    \n    # NB: to return just the results column...\n    # as.data.frame(converted$values)\n    \n  })\n  \n  \n  output$lengthConvertH <- renderUI({\n    \n    numericInput('lengthInputH', input$lengthUnitsH,\n                 isolate(currentLengthH()), 0, 1000, stepFtAndIn())\n    \n  })\n  \n  \n  output$lengthTableH <- DT::renderDataTable(\n    \n    datatable(lengthResults(), \n              rownames = F, \n              \n              options = list(dom = 't', \n                             'bSort' = F, \n                             'bInfo' = F, \n                             pageLength = 8,\n                             \n                  # see: https://rstudio.github.io/DT/010-style.html\n                             columnDefs = list(list(targets = 4, visible = F), \n                                               list(className = 'dt-center', targets = c(1:3))),\n                  \n                  # see: http://rstudio.github.io/DT/options.html\n                  initComplete = JS(\n                    \"function(settings, json) {\",\n                    \"$(this.api().table().header()).css({'background-color': '#000', 'color': '#fff'});\",\n                    \"}\")\n                  \n                  # ), \n                  )) %>% \n\n              # selection = list(target = 4, visible = F)) %>% \n              # selection = list(target = 'row+column')) %>% \n      \n      formatStyle(c('units', 'Length 1', 'Length 2', 'Sum'),\n                  textAlign = 'right') %>% \n      \n      formatStyle('units',\n                  color = 'white',\n                  backgroundColor = '#22316C',\n                  fontWeight = 'bold',\n                  fontStyle = 'italic',\n                  width = 180) %>% \n      \n      formatStyle('Sum',\n                  color = 'white',\n                  backgroundColor = '#6F6B6B'\n                  ) %>% \n      \n# style data-entry cell using 'hidden' column, set in lengthResults()\n# see: https://rstudio.github.io/DT/010-style.html\n      formatStyle(input$radLengthH, 'hidden', \n                  backgroundColor = styleEqual(c(0, 1), c('#6699FF', '#FFFF66')),\n                  fontWeight = styleEqual(c(0, 1), c('normal', 'bold')))\n    \n# see: http://stackoverflow.com/questions/33364594/how-to-force-formatstyle-in-datatable-shiny-to-output-formatting-based-on-othe\n\n    )   # end DT::renderDataTable for lengthTableH\n  \n\n# see: yihui.shinyapps.io/DT-proxy\n  proxy <- dataTableProxy('lengthTableH')\n  \n  observeEvent(lengthResults(), {\n  # observeEvent(datatable(lengthResults(), selection = list(target = 'cell') %>% formatStyle()), {\n    \n#     idx <- which(input$lengthUnitsH == lengthUnitsChoices)\n#     cat('INDEX = ', idx, '\\n')\n# ERROR with idx as second @param...\n# Input to asJSON(keep_vec_names=TRUE) is a named vector. \n# In a future version of jsonlite, this option will not be supported, \n# and named vectors will be translated into arrays instead of objects. \n# If you want JSON object output, please use a named list instead. See ?toJSON.\n    \n    \n# select ROWS...\n#     if(input$lengthUnitsH == lengthUnitsChoices[1]) {\n#       selectRows(proxy, 1)\n#     } else if(input$lengthUnitsH == lengthUnitsChoices[2]){\n#       selectRows(proxy, 2)\n#     } else if(input$lengthUnitsH == lengthUnitsChoices[3]){\n#       selectRows(proxy, 3)\n#     } else if(input$lengthUnitsH == lengthUnitsChoices[4]){\n#       selectRows(proxy, 4)\n#     } else\n      selectRows(proxy, NULL)\n    \n# select COLUMNS...    \n    if(input$radLengthH == 'Length 1') {\n      selectColumns(proxy, 1)\n    } else if(input$radLengthH == 'Length 2'){\n      selectColumns(proxy, 2)\n    } else\n      selectColumns(proxy, NULL)\n    \n  })\n  \n  \n  \n  # ---- renderUI AREA ----\n  \n  # persists current area input\n  # isolated in re-rendering areaConvert numericInput in output$areaConvert <- renderUI...\n  currentArea <- reactive({\n    if(is.null(input$areaInput))\n      areaToConvert\n    else\n      input$areaInput\n  })\n  \n  output$echoAreaInput <- renderUI({\n      value <- input$areaInput\n      units <- input$areaConvertUnits\n      \n      tags$code(\n        HTML('<h2><b>Convert: ', value, ' ', units)\n      )\n  })\n  \n  areaResults <- reactive({\n    \n    my.icArea <- currentArea()\n    my.input.area <- input$areaConvertUnits\n    \n    converted <- convertAll(my.icArea, my.input.area, area.data)\n    \n    nums <- as.numeric(converted$values)\n    \n    #     # round converted values as appropriate\n    # converted$values[-c(4:5)] <- signif(nums[-c(4:5)], 4)\n    \n    format(converted, digits = 6, scientific = F)\n    \n  })\n  \n  output$areaConvert <- renderUI({\n    \n    numericInput('areaInput', input$areaConvertUnits,\n                 isolate(currentArea()), 0, 1000, 0.1)\n  })\n  \n  output$areaTable <- DT::renderDataTable(\n    \n    areaResults(),\n    rownames = F,\n    options = list(dom = 't', 'bSort' = F)\n  )\n  \n  \n  \n  # ---- 'HORIZ' ** VOLUME ** INPUT ----\n  \n  # persists current volume input\n  # isolated in re-rendering volumeConvert numericInput in output$volumeConvert <- renderUI...\n  currentVolumeH <- reactive({\n    \n    if(is.null(input$volumeInputH))\n      volumeToConvert\n    else\n      input$volumeInputH\n  })\n  \n  # capture change of input volume conversion units to change...\n  #   * step parameter of selectInput (0 for whole English units, 0.1 for all metric units)\n  #   * conversion function in converter.R to calculate data.frame of results\n#   stepFtAndIn <- reactive({\n#     \n#     if(input$lengthUnitsH == 'yards') {\n#       # convertFtAndInchesToMeters(0, 1, 0)\n#       mystep <- 0\n#     } else {\n#       mystep <- 0.1\n#     }\n#   })\n  \n  \n  volumeResults <- reactive({\n    \n    my.liters <- currentVolumeH()\n    my.input.volume <- input$volumeUnitsH\n    \n    # converted <- convertAll(my.liters, my.input.volume, vol.data)\n    converted <- convertAll(my.liters, my.input.volume, vol.data)\n    \n    nums <- as.numeric(converted$values)\n    \n    # use a hidden column to aid in highlighting the cell in which the user enters a datum to convert\n    oldConvertedVolumes$hidden <- c(0, 0, 0, 0, 0, 0, 0)\n    \n    cell.idx <- which(volumeUnitsChoices == input$volumeUnitsH)\n    \n    oldConvertedVolumes$hidden[cell.idx] <- 1\n    \n    # round converted values as appropriate\n    converted$values[-c(4:5)] <- signif(nums[-c(4:5)], 4)\n    \n    if(isolate(input$radVolumeH) == 'Volume 1') {\n      oldConvertedVolumes$'Volume 1' <- converted$values\n    } else {\n      oldConvertedVolumes$'Volume 2' <- converted$values\n    }\n    \n    # calculate SUM, based on liters\n    # get index of IC volume units\n    idx.ic.vol <- which(vol.data$units == vol.data$icUnits)\n    sum.liters <- as.numeric(oldConvertedVolumes$'Volume 1'[idx.ic.vol]) + \n                  as.numeric(oldConvertedVolumes$'Volume 2'[idx.ic.vol])\n    sums <- convertAll(sum.liters, vol.data$icUnits, vol.data)\n    \n    # assign sum to display df\n    oldConvertedVolumes$Sum <- sums$values\n    \n    oldConvertedVolumes <<- oldConvertedVolumes\n    \n  })\n  \n  \n  output$volumeConvertH <- renderUI({\n    \n    numericInput('volumeInputH', input$volumeUnitsH,\n                 isolate(currentVolumeH()), 0, 1000, 0.1)\n    \n  })\n  \n  \n  output$volumeTableH <- DT::renderDataTable(\n    \n    datatable(volumeResults(), \n              rownames = F, \n              \n              options = list(dom = 't', \n                             'bSort' = F, \n                             'bInfo' = F, \n                             pageLength = 8,\n                             \n                             # see: https://rstudio.github.io/DT/010-style.html\n                             columnDefs = list(list(targets = 4, visible = F), \n                                               list(className = 'dt-center', targets = c(1:3))),\n                             \n                             # see: http://rstudio.github.io/DT/options.html\n                             initComplete = JS(\n                               \"function(settings, json) {\",\n                               \"$(this.api().table().header()).css({'background-color': '#000', 'color': '#fff'});\",\n                               \"}\")\n                             \n                             # ), \n              )) %>% \n      \n      formatStyle(c('units', 'Volume 1', 'Volume 2', 'Sum'),\n                  textAlign = 'right') %>% \n      \n      formatStyle('units',\n                  color = 'white',\n                  backgroundColor = '#22316C',\n                  fontWeight = 'bold',\n                  fontStyle = 'italic',\n                  width = 180) %>% \n      \n      formatStyle('Sum',\n                  color = 'white',\n                  backgroundColor = '#6F6B6B'\n      ) %>% \n      \n      # style data-entry cell using 'hidden' column, set in lengthResults()\n      # see: https://rstudio.github.io/DT/010-style.html\n      formatStyle(input$radVolumeH, 'hidden', \n                  backgroundColor = styleEqual(c(0, 1), c('#6699FF', '#FFFF66')),\n                  fontWeight = styleEqual(c(0, 1), c('normal', 'bold')))\n    \n    # see: http://stackoverflow.com/questions/33364594/how-to-force-formatstyle-in-datatable-shiny-to-output-formatting-based-on-othe\n    \n  )   # end DT::renderDataTable for volumeTableH\n  \n  \n  # see: yihui.shinyapps.io/DT-proxy\n  proxy <- dataTableProxy('volumeTableH')\n  \n  observeEvent(volumeResults(), {\n    \n    selectRows(proxy, NULL)\n    \n    # select COLUMNS...    \n    if(input$radVolumeH == 'Volume 1') {\n      selectColumns(proxy, 1)\n    } else if(input$radVolumeH == 'Volume 2'){\n      selectColumns(proxy, 2)\n    } else\n      selectColumns(proxy, NULL)\n    \n  })\n  \n  \n  # ---- ** VOLUME AREA x DEPTH ** INPUT ----\n  \n  radAxD <- reactive({\n    \n    if(input$volumeRadAxD == 'Area')\n      1\n    else\n      2\n  })\n  \n  # persists current volume input\n  # isolated in re-rendering volumeConvert numericInput in output$volumeConvert <- renderUI...\n  currentValueAxD <- reactive({\n    \n#     if(radAxD() == 2)\n#       depthToConvertAxD <- input$volumeInputAxD\n#     else\n#       volumeToConvertAxD <- input$volumeInputAxD\n    \n    rb.hit <- radAxD()\n    \n    # cat('\\n\\nBEFORE...', numericInput_volumeAxD, '\\n')\n    # cat('              rb.hit:', rb.hit, '\\n')\n    # cat('input$volumeInputAxD:', input$volumeInputAxD, '\\n')\n    # \n    # numericInput_volumeAxD[rb.hit] <- input$volumeInputAxD\n    # \n    # cat('  AFTER...', numericInput_volumeAxD, '\\n\\n')\n    \n    # input$volumeInputAxD\n    numericInput_volumeAxD[rb.hit]\n    \n  })\n  \n  currentUnitsAxD <- reactive({\n    \n    rb.hit <- radAxD()\n\n    # NB: areaOrDepthUnitsChoices[[rb.hit]] is the list of choices for current radio button, 'Area' or 'Depth'\n    if(input$volumeSelectAxD %in% areaOrDepthUnitsChoices[[rb.hit]]$units) {\n      \n      # persist\n      selectionChoice_volumeAxD[rb.hit] <<- input$volumeSelectAxD\n      \n      input$volumeSelectAxD\n    } else {\n      \n      # old.hit <- ifelse(rb.hit == 1, 2, 1)\n      \n      # send persisted units for current RB hit\n      selectionChoice_volumeAxD[rb.hit]\n    }\n    \n  })\n  \n  \n  volumeResultsAxD <- reactive({\n    \n    rb.hit <- radAxD()\n    my.AxD.value <- currentValueAxD()\n    my.AxD.units <- currentUnitsAxD()\n    \n    my.input.units <- input$volumeSelectAxD\n    \n    # [KLUDGE] First time through, if Depth(s) = 0...\n    # NB: **weak* conditional assuming at least one element '0' && assuming initial input = '1 m'\n    if('0' %in% oldConvertedVolumesAxD$'Depth') {\n      \n      converted.depth <- convertAll(1.0, 'm', areaOrDepthUnitsChoices[[2]])\n      oldConvertedVolumesAxD$Depth <- converted.depth$values[1:7]\n    }\n    \n    if(rb.hit == 2) {\n      \n      # print('in DEPTH...')\n      \n      # if(my.input.units == 'yards') {\n      if(my.AxD.units == 'yards') {\n        \n        my.meters <- convertYdFtAndInchesToMeters(currentValueAxD(),\n        # my.meters <- convertYdFtAndInchesToMeters(my.AxD.value,\n                                                  input$feetConvertAxD,\n                                                  input$inchConvertAxD,\n                                                  input$fractionalInchConvertUnitsAxD)\n        \n        # [KLUDGE] for imprecision...\n        my.meters <- round(my.meters, 8)\n        my.input.units <- 'm'\n        \n      } else {\n        \n        # my.meters <- currentValueAxD()\n        my.meters <- my.AxD.value\n        my.input.units <- my.AxD.units\n        \n      }\n      \n      # converted <- convertAll(currentValueAxD(), my.AxD.units, areaOrDepthUnitsChoices[[2]])\n      converted <- convertAll(my.meters, my.input.units, areaOrDepthUnitsChoices[[2]])\n      \n      # round converted values as appropriate\n      #     num <- as.numeric(converted.2$values[-c(4:5)])\n      #     converted.2$values[-c(4:5)] <- signif(num[-c(4:5)], 4)\n      \n      converted$result <- c(paste(converted$values[1:3], lengthUnits[1:3]),\n                              converted$values[4:5],\n                              paste(converted$values[6:8], lengthUnits[6:8]))\n      \n    } else {     # ...NB: if rb not 'Depth', then 'Area'...\n      \n      # print('in AREA...')\n      \n      # [TEST] converting Area\n      # areaOrDepthUnitsChoices <- list(Area = area.data, Depth = length.data)\n      my.input.units <- my.AxD.units\n      \n      converted <- convertAll(currentValueAxD(), my.input.units, areaOrDepthUnitsChoices[[1]])\n      \n      # round converted values as appropriate\n      # converted$values[-c(4:5)] <- signif(nums[-c(4:5)], 4)\n      converted$values <- signif(converted$values, 4)\n      \n      converted <- converted %>% mutate(result = paste(converted$values, converted$units))\n      \n    }\n    \n    # cat('CONVERTED ', my.AxD.value, my.AxD.units, '\\n')\n    # print(converted)\n    \n    # perform volume calculation\n    new.volume <- 0\n    \n    if(radAxD() == 1) {        # AREA\n      \n      oldConvertedVolumesAxD$Area <- converted$value[1:7]\n      \n      # a <- as.numeric(oldConvertedVolumesAxD$Area[2])\n      # z <- as.numeric(oldConvertedVolumesAxD$Depth[1])\n      # new.volume <- a * z\n      \n    } else {                   # DEPTH\n      \n      oldConvertedVolumesAxD$Depth <- converted$value[1:7]\n      \n      # a <- as.numeric(oldConvertedVolumesAxD$Area[2])\n      # z <- as.numeric(oldConvertedVolumesAxD$Depth[1])\n      # new.volume <- a * z\n    }\n    \n    a <- as.numeric(oldConvertedVolumesAxD$Area[2])\n    z <- as.numeric(oldConvertedVolumesAxD$Depth[1])\n    new.volume <- a * z\n    \n    \n    # use a hidden column to aid in highlighting the cell in which the user enters a datum to convert\n    oldConvertedVolumesAxD$hidden <- c(0, 0, 0, 0, 0, 0, 0)\n    \n    cell.idx <- which(areaOrDepthUnitsChoices[[rb.hit]]$units == my.AxD.units)\n    \n    # cat('CELL.IDX for ', areaOrDepthUnitsChoices[[rb.hit]]$units, 'and', my.AxD.units,'=', cell.idx,'\\n')\n#     cell.idx <- which(volumeUnitsChoices == input$volumeUnitsH)\n    \n    oldConvertedVolumesAxD$hidden[cell.idx] <- 1\n    \n    # print('********************* converted.vol *********************************')\n    converted.vol <- convertAll(new.volume, 'cubic meters (m\\U00B3)', vol.data)\n    \n    converted.vol$values <- signif(converted.vol$values, 4)\n    \n    # print(paste(converted.vol$values, oldConvertedVolumesAxD.Short))\n    # print(appendUnits(converted.vol$values, oldConvertedVolumesAxD.Short))\n    \n    oldConvertedVolumesAxD$Volume <- converted.vol$values\n    \n    # persist state\n    oldConvertedVolumesAxD <<- oldConvertedVolumesAxD\n    \n    # attach units for display\n    df.area <- paste(oldConvertedVolumesAxD$Area, areaUnitsChoices)\n    df.depth <- c(paste(oldConvertedVolumesAxD$Depth[1:3], lengthUnits[1:3]),\n                  oldConvertedVolumesAxD$Depth[4:5],\n                  paste(oldConvertedVolumesAxD$Depth[6:7], lengthUnits[6:7]))\n    df.volume <- paste(oldConvertedVolumesAxD$Volume, oldConvertedVolumesAxD.Short)\n    df.units <- oldConvertedVolumesAxD$units\n    df.hidden <- oldConvertedVolumesAxD$hidden\n    \n    # NB: WHICH newly converted volume should be displayed in formula?? and how best? \n    # va bene -- must parameterize & persist index of last df.volume row clicked\n    volume <<- df.volume[my.volume.index]\n    \n    # #2 of 3...\n    # 1. observeEvent(c(currentUnitsAxD(), input$volumeInputAxD)...)\n    # 2. here (volumeResultsAxD)\n    # 3. observeEvent(input$volumeTableAxD_cell_clicked...)\n    \n    formula.AxD(area, depth, volume)\n    \n    df.display <- data.frame(Area = df.area, \n                             Depth = df.depth, \n                             Volume = df.volume, \n                             units = df.units, \n                             hidden = df.hidden)\n    \n    df.display\n    \n  })\n  \n  \n  # observe table click\n  # see: \n  \n  observeEvent(input$volumeTableAxD_cell_clicked, {\n    \n    selectRows(proxy, NULL)\n    \n    info = input$volumeTableAxD_cell_clicked\n    \n    # cat('row:', info$row, 'col:', info$col, '\\n')\n    \n    if(is.null(info$value)) return()\n    \n    # NB: javascript, 0-indexed\n    if(info$col == 0)\n      area <<- info$value\n    else if(info$col == 1) \n      depth <<- info$value\n    else if(info$col == 2) {\n      volume <<- info$value\n      # cat('...AAA. my.volume.index =', my.volume.index, '\\n')\n      my.volume.index <<- info$row\n      # cat('...BBB. my.volume.index =', my.volume.index, '\\n')\n    } else\n      return\n    \n    # my.formula <- paste0('(', area, ') x (', depth, ') = (', volume, ')')\n    # my.volume.index <- info$row\n    # cat('1. my.volume.index =', my.volume.index, '\\n')\n    # my.formula <- paste0('(', area, ') x (', depth, ') = ', volume)\n    \n    formula.AxD(area, depth, volume)\n      \n    output$formulaAxD <- renderText(my.formula)\n    \n    }\n  )\n  \n  \n  output$volumeTableAxD <- DT::renderDataTable(\n    \n    datatable(volumeResultsAxD(), \n              \n              # selectRows(proxy, NULL),\n              \n              rownames = F, \n              \n              options = list(dom = 't', \n                             'bSort' = F, \n                             'bInfo' = F, \n                             pageLength = 8,\n                             # processing = F,\n                             \n                             # see: https://rstudio.github.io/DT/010-style.html\n                             columnDefs = list(list(targets = 4, visible = F), \n                                               list(className = 'dt-center', targets = c(1:3))),\n                             \n                             # see: http://rstudio.github.io/DT/options.html\n                             initComplete = JS(\n                               \"function(settings, json) {\",\n                               \"$(this.api().table().header()).css({'background-color': '#000', 'color': '#fff'});\",\n                               \"}\")\n                             \n                             # ), \n              )) %>% \n      \n      # formatStyle(c('units', 'Area', 'Depth', 'Volume'),\n      formatStyle(c('Area', 'Depth', 'Volume'),\n                  textAlign = 'right') %>% \n      \n      formatStyle('units',\n                  color = 'white',\n                  backgroundColor = '#22316C',\n                  fontWeight = 'bold',\n                  fontStyle = 'italic',\n                  width = 180) %>% \n      \n      formatStyle('Volume',\n                  color = 'white',\n                  backgroundColor = '#6F6B6B'\n      ) %>% \n      \n      # style data-entry cell using 'hidden' column, set in lengthResults()\n      # see: https://rstudio.github.io/DT/010-style.html\n      # formatStyle(input$radVolumeAxD, 'hidden', \n      formatStyle(input$volumeRadAxD, 'hidden', \n                  backgroundColor = styleEqual(c(0, 1), c('#6699FF', '#FFFF66')),\n                  fontWeight = styleEqual(c(0, 1), c('normal', 'bold')))\n    \n  )   # end DT::renderDataTable for volumeTableAxD\n  \n  \n# ---- Proxy: volumeTableAxD ----\n  \n  # observe({\n  #   replaceData(proxy, loopData(), resetPaging = FALSE)\n  # })\n  \n  # see: yihui.shinyapps.io/DT-proxy\n  proxy <- dataTableProxy('volumeTableAxD')\n  \n  observeEvent(volumeResultsAxD(), {\n    \n    selectRows(proxy, NULL)\n    \n    # select COLUMNS...    \n    # if(!is.null(input$radVolumeAxD)) {\n    if(!is.null(radAxD()) & !is.null(volumeResultsAxD())) {\n      \n      if(radAxD() == 'Area') {\n        selectColumns(proxy, 1)\n      } else if(radAxD() == 'Depth'){\n        selectColumns(proxy, 2)\n        # selectColumns(proxy, 3)\n      } else\n        selectColumns(proxy, NULL)\n      \n    }\n    \n  })\n  \n  \n  \n  # ---- render Flow Rate Table ----\n  \n  flowResults <- reactive({\n    df <- convertAll(input$flowRateConvert, input$flowRateConvertUnits, flow)\n    format(df, digits = 6, scientific = F)\n  })\n  \n  output$flowRateConversionTable <- DT::renderDataTable(\n    \n    flowResults(),\n    rownames = F,\n    # see: http://www.datatables.net/reference/option/dom\n    # dom = 'tp' option for table + pagination only\n    options = list(dom = 'tp', 'bSort' = F, pageLength = 5)\n    \n  )\n  \n  \n  # ---- render Biomass Table ----\n  \n  biomassResults <- reactive({\n    # [TEST] convertBiomass()...\n    # ('kg/m²', 'g/m²', 'lb/m²', 'lb/ft²',\n    # 'kg/m³', 'g/L', 'lb/gal (US)', 'lb/gal (UK)', 'lb/ft³')\n    icZ <- convertDepth(input$depthConvert, input$depthConvertUnits, length)\n    convertBiomass(input$biomassConvert, input$biomassConvertUnits, biomass, icZ)\n    \n    df <- convertAll(input$biomassConvert, input$biomassConvertUnits, biomass)\n    format(df, digits = 6, scientific = F)\n  })\n  \n  output$biomassConversionTable <- DT::renderDataTable(\n    \n    biomassResults(),\n    rownames = F,\n    options = list(dom = 't', 'bSort' = F, pageLength = 25)\n    \n  )\n  \n  \n  \n  # ---- T, S, rho conversions ----\n  \n  # see: http://shiny.rstudio.com/reference/shiny/latest/updateSliderInput.html\n  observe({\n    \n    temp_units <- input$tempConvertUnits\n    \n    if (is.null(temp_units))\n      return()\n    \n    \n    idx <- which(temp_units == tempUnitsList)\n    \n    \n    # Control the value, min, max, and step.\n    # Step size is 2 when input value is even; 1 when value is odd.\n    updateSliderInput(session, \"tempSlider_convert\", label = tempUnitsList[idx], \n                      value = tempSet[idx],\n                      min = tempMin[idx], max = tempMax[idx], step = tempStep[idx])\n  })\n  \n  \n  # Salinity\n  observe({\n    \n    sal_units <- input$salConvertUnits\n    \n    if (is.null(sal_units))\n      return()\n    \n    \n    idx <- which(sal_units == salUnitsList_short)\n    # sal <- salToIcUnits(salSet[idx], idx, 30+273.15, 0)\n    \n    if(idx %in% c(6:9)) {\n      show('tc')\n    } else {\n      hide('tc')\n    }\n    \n    \n    # Control the value, min, max, and step.\n    # Step size is 2 when input value is even; 1 when value is odd.\n    updateSliderInput(session, \"salSlider_convert\", label = salUnitsList[idx], \n                      value = salSet[idx],\n                      min = salMin[idx], max = salMax[idx], step = salStep[idx])\n  })\n  \n  \n  output$temp_sal_output <- renderPrint({\n    \n    idx_t <- which(input$tempConvertUnits == tempUnitsList)\n    temp <- tempToIcUnits(input$tempSlider_convert, idx_t)\n    \n    idx_s <- which(input$salConvertUnits == salUnitsList_short)\n    sal <- salToIcUnits(input$salSlider_convert, idx_s, temp, input$tc)\n    # sal <- salToIcUnits(input$salSlider, idx_s, 30+273.15, 0)\n    \n    rho <- calcRho(temp, sal)   # kg/m3 (g/L)\n    \n    # df <- tempToAllUnits(temp)\n    # print(df)\n    \n    # h_input_val <- 1.01495\n    # h_input_idx <- 6\n    # tc <- input$tc\n    # x <- salToAllUnits(h_input_val, h_input_idx, sal, temp, tc)\n    \n    sal_h <- 1.01\n    \n    salToAllUnits(sal_h, temp)\n    \n    # print(x)\n    # print(salToIcUnits(1.008214, 6, temp, tc))\n    # print(salToIcUnits(1.007461, 6, temp, tc))\n    \n    cat(input$tempSlider_convert,' ', tempUnitsList_short[idx_t], ' = ', temp, ' K\\n')\n    cat(input$salSlider_convert,' ', salUnitsList_short[idx_s], ' = ', sal, ' ppt\\n')\n    cat('\\n rho = ', rho/1000.0, ' kg/L')\n  })\n  \n  # supply dfs for temp, sal, rho conversions\n  \n  df_temp <- reactive({\n    \n    idx_t <- which(input$tempConvertUnits == tempUnitsList)\n    temp <- tempToIcUnits(input$tempSlider_convert, idx_t)\n    \n    df <- tempToAllUnits(temp)\n    \n    df\n  })\n  \n  df_sal <- reactive({\n    \n    idx_t <- which(input$tempConvertUnits == tempUnitsList)\n    temp <- tempToIcUnits(input$tempSlider_convert, idx_t)\n    \n    idx_s <- which(input$salConvertUnits == salUnitsList_short)\n    sal <- salToIcUnits(input$salSlider_convert, idx_s, temp, input$tc)\n    \n    # df <- salToAllUnits(sal)\n    \n    df <- data.frame(vals = c(3, 2, 1), \n                     units = c('Moe!', 'Larry!!', 'Curley!!!'))\n  })\n  \n  \n  # ---- T, S, rho conversions DTs ----\n  \n  proxy_dt_temp_data = dataTableProxy('dt_temp_conv')\n  \n  observe({\n    replaceData(proxy_dt_temp_data, df_temp(), rownames = F, resetPaging = FALSE)\n  })  \n  \n  output$dt_temp_conv <- DT::renderDataTable(\n    \n    datatable( isolate(df_temp()),\n               \n               rownames = F,\n               \n               options = list(dom = 't',\n                              'bSort' = F,\n                              'bInfo' = F,\n                              pageLength = 3,\n                              \n                              # see: http://rstudio.github.io/DT/options.html\n                              initComplete = JS(\n                                \"function(settings, json) {\",\n                                \"$(this.api().table().header()).css({'background-color': 'lightblue', 'color': '#000'});\",\n                                \"}\")\n               )\n    )\n  )\n  \n  \n  proxy_dt_sal_data = dataTableProxy('dt_sal_conv')\n  \n  observe({\n    replaceData(proxy_dt_sal_data, df_sal(), rownames = F, resetPaging = FALSE)\n  })  \n  \n  output$dt_sal_conv <- DT::renderDataTable(\n    \n    datatable( isolate(df_sal()),\n               \n               rownames = F,\n               \n               options = list(dom = 't',\n                              'bSort' = F,\n                              'bInfo' = F,\n                              pageLength = 3,\n                              \n                              # see: http://rstudio.github.io/DT/options.html\n                              initComplete = JS(\n                                \"function(settings, json) {\",\n                                \"$(this.api().table().header()).css({'background-color': 'lightblue', 'color': '#000'});\",\n                                \"}\")\n               )\n    )\n  )\n  \n  \n  \n  # ---- renderUI TEMP slider ----\n  \n  output$tempSliderUI <- renderUI({\n    \n    idx <- which(input$tempUnits == tempUnitsList)\n    \n    sliderInput('tempSlider',\n                tempUnitsList[idx],\n                tempMin[idx], tempMax[idx],\n                tempSet[idx], tempStep[idx])\n  })\n  \n  \n  # ---- renderUI SALINITY slider ----\n  \n  output$salSlider <- renderUI({\n    \n    # cat('----- BEGIN RENDER SLIDER -------\\n')\n    # cat(' 0.   input$salSlider:',input$salSlider, '\\n')\n    \n    #     idx <- as.numeric(input$salUnits)\n    idx <- which(input$salUnits == salUnitsList)\n    \n    sliderInput('salSlider',\n                salUnitsList[idx],\n                salMin[idx], salMax[idx],\n                salSet[idx], salStep[idx])\n  })\n  \n  # ---- renderUI CRIT UIA ----\n  \n  # output$critTanVal <- renderUI({\n  #   \n  #   idx <- which(input$critTanUnits == critUiaUnitsList)\n  #   \n  #   numericInput('critTanVal',\n  #                'Critical TAN',\n  #                critUiaMin[idx],\n  #                critUiaMax[idx],\n  #                critUiaSet[idx],\n  #                critUiaStep[idx])\n  # })\n  \n  \n  output$testPlot <- renderPlot({\n    \n    # data: get %age UIA, subtract from 100\n    # main  needs pH, T, & S\n    \n    # bad <- uiaPoSto()\n    # \n    # my_data <- table(bad, 100 - bad)\n    # \n    # barplot(c(bad, 100 - bad), col = c('red', 'darkgreen'),\n    # # barplot(my_data, col = c('darkgreen', 'red'), \n    #         ylim = c(0, 100), ylab = 'percent', \n    #         names.arg = c('UIA', '\\\"safe\\\" ammonia'), main = paste0(round(bad, 2), \n    #                                                                 '% UIA at pH ', input$phSlider, ',\\n', \n    #                                                                 input$tempSlider, ' ', input$tempUnits, ',\\n',\n    #                                                                 input$salSlider, ' ', input$salUnits))\n    \n    \n    if(is.null(input$tempSlider))\n      temp <- initValues$t\n    else {\n      idx <- which(input$tempUnits == tempUnitsList)\n      cat('0. input$tempSlider: ', ' ', input$tempSlider, '\\n')\n      temp <- tempToIcUnits(input$tempSlider, idx)\n      cat('1. temp: ', temp, ' ', input$tempUnits, '\\n\\n')\n    }\n    \n    \n    if(is.null(input$salSlider))\n      sal <- initValues$s\n    else {\n      sal <- input$salSlider\n      # idx <- which(input$salUnits == salUnitsList)\n      # sal <- salToIcUnits(input$salSlider, idx, temp, 0)\n    }\n    \n    \n    if(is.null(input$phSlider))\n      ph <- initValues$ph\n    else\n      ph <- input$phSlider\n    \n    tan <- input$tanVal\n    crit_tan <- input$critTanVal\n    \n    \n    # if(!is.nan(critPh_FREE)) {\n    if(tan > crit_tan) {\n      \n      critPh_FREE <- critPhFreeForTanMillero(tan, crit_tan, temp, sal)\n      \n      critPh_NBS <- critPh_FREE - log10(ahFreeToSwsFactor(sal, temp, 0)) -\n        log10(ahSwsToNbsFactor(sal, temp, 0))\n      \n      critPh_NBS <- round(critPh_NBS, 3)\n      critPh_NBS_alert <- round(critPh_NBS - 0.20, 3)\n      \n      # critTan UNDEFINED when tan <= input$critTanVal ??\n      critTan <- round(input$critTanVal / (uiaPoSto() / 100.0), 4)\n      \n      # deltaPh <- round((input$phSlider - critPh_NBS), 4)\n      deltaTan <- round((input$tanVal - critTan), 4)\n      \n      deltaPh <- round((input$phSlider - critPh_NBS), 4)\n      \n      df <- calcUiaPoSto(temp, sal)\n      \n      bad <- round(uiaPoSto(), 2)\n      \n      \n      df %>% ggplot(aes(pH, percent)) + geom_line() + labs(y = \"Percent UIA\") +\n        geom_vline(xintercept = critPh_NBS_alert, col = 'green') +\n        geom_vline(xintercept = critPh_NBS, col = 'red') + \n        annotate(\"rect\", xmin=-Inf, xmax=(critPh_NBS - 0.2), ymin=-Inf, ymax=Inf, fill=\"green\", alpha=0.4) +  \n        annotate(\"rect\", xmin=(critPh_NBS - 0.2), xmax=critPh_NBS, ymin=-Inf, ymax=Inf, fill=\"yellow\", alpha=0.4) +   \n        annotate(\"rect\", xmin=critPh_NBS, xmax=Inf, ymin=-Inf, ymax=Inf, fill=\"red\", alpha=0.4) +  \n        # annotate(\"text\", 6.2, 15, label = paste0(round(uiaPoSto(), 2),'% UIA\\n', \n        #                                          input$tempSlider, ' ', input$tempUnits), hjust=0) + \n        geom_point(aes(input$phSlider, bad), size=3)\n      \n    } else {\n      \n      critPh_NBS <- 'n/a'\n      critTan <- 'n/a'\n      \n      deltaPh <- 'n/a'\n      deltaTan <- 'n/a'\n      \n      ggplot(NULL) +  \n        annotate(\"text\", 10, 15, label = paste0('TAN must be > UIA'))\n    }\n    \n    \n    \n    \n    # plot(df$pH, df$percent,\n    #      type = 'l',\n    #      xlab = 'pH (NBS)', ylab = '% UIA',\n    #      main = paste0(bad,\n    #                    '% UIA at pH ', input$phSlider, ',\\n',\n    #                    input$tempSlider, ' ', input$tempUnits, ',\\n',\n    #                    input$salSlider, ' ', input$salUnits))\n    # \n    # abline(v = critPh_NBS, col = 'red')\n    # \n    # points(input$phSlider, bad, col = 'blue', pch = 19)\n    # \n    # polygon(c(critPh_NBS, 5, 5, critPh_NBS), c(-5, -5, 50, 50),\n    #         col=rgb(0, 1, 0,0.35), border = NA)\n    # polygon(c(critPh_NBS, 9.5, 9.5, critPh_NBS), c(-5, -5, 50, 50),\n    #         col=rgb(1, 0, 0,0.35), border = NA)\n      \n  })\n  \n# ---- Box 'warning' titles ----\n  output$uiaTitleText <- renderText({\n    \n    idx_temp <- which(input$tempUnits == tempUnitsList)\n    # temp <- tempToIcUnits(input$tempSlider, idx)\n    idx_sal <- which(input$salUnits == salUnitsList)\n    \n    paste0(round(uiaPoSto(), 2),'% UIA at pH ',\n           # input$tempSlider, ' ', input$tempUnits)\n           input$phSlider, ', ',\n           input$tempSlider, ' ', tempUnitsList_short[idx_temp], ', ',\n           input$salSlider, ' ', salUnitsList_short[idx_sal])\n  })\n  \n  output$critTitleText <- renderText({\n    paste0('Critical Levels')\n  })\n  \n  \n  # ---- reactiveValues for UIA ----\n  \n  initValues <- reactiveValues(flag = 0,\n                               t = 28 + 273.15,\n                               s = 30,\n                               ph = 7.2,\n                               tan = 1.0,\n                               crit_tan = 0.025)\n  \n  \n  \n  # ---- UIA InfoBox ----\n  \n  \n  # vector of [UIA] for domain of TAN values\n  # tanDomain <- c(0:10, 0.01)\n  # for(i in tanDomain)\n  #   print(round( (calcUiaPoSto(temp, sal, ph.NBS) / 100), 2) )\n  \n  # called to plot UIA % as f(pH) (another for g(TAN))\n  \n  calcUiaPoSto <- function(temp, sal) {\n    \n    # NB: temp & sal in I.C. units\n    \n    posto.range <- c()\n    \n    ph.min <- 6.0\n    ph.max <- 9.0\n    p.step <- 0.01\n    \n    ph.domain <- seq(ph.min, ph.max, p.step)\n    \n    for(ph in ph.domain) {\n      \n      ph.free <- phNbsToPhFree(ph, sal, temp, 0)\n      \n      posto.range <- c(posto.range, percentNh3ForTemp(temp, sal, ph.free))\n    }\n    \n    df <- data.frame(pH = ph.domain, percent = posto.range)\n    \n  }\n  \n  \n  uiaPoSto <- reactive({\n    \n    if(is.null(input$tempSlider))\n      temp <- initValues$t\n    else {\n      idx <- which(input$tempUnits == tempUnitsList)\n      temp <- tempToIcUnits(input$tempSlider, idx)\n    }\n    \n    \n    if(is.null(input$salSlider))\n      sal <- initValues$s\n    else {\n      sal <- input$salSlider\n      # idx <- which(input$salUnits == salUnitsList)\n      # sal <- salToIcUnits(input$salSlider, idx, temp, 0)\n    }\n    \n    \n    ph.free <- phNbsToPhFree(input$phSlider,\n                             sal,\n                             temp,\n                             0)\n    \n    percentNh3ForTemp(temp, sal, ph.free)\n    \n  })\n  \n\n  output$unIonAmmValBox <- renderInfoBox({\n    \n    # vector of [UIA] for domain of TAN values\n    # tanDomain <- c(0:10)\n    # for(i in tanDomain)\n    #   print(round((uiaPoSto() / 100) * i))\n    \n    if(is.null(input$tempSlider))\n      temp <- initValues$t\n    else {\n      idx <- which(input$tempUnits == tempUnitsList)\n      temp <- tempToIcUnits(input$tempSlider, idx)\n    }\n    \n    \n    if(is.null(input$salSlider))\n      sal <- initValues$s\n    else {\n      sal <- input$salSlider\n      # idx <- which(input$salUnits == salUnitsList)\n      # sal <- salToIcUnits(input$salSlider, idx, temp, 0)\n    }\n    \n    \n    if(is.null(input$phSlider))\n      ph <- initValues$ph\n    else\n      ph <- input$phSlider\n    \n    \n    tan <- input$tanVal\n    crit_tan <- input$critTanVal\n    \n    \n    # [TRAP] case TAN = 0\n    if(tan != 0) {\n      \n      # 1. calc current UIA from icTan() & uiaPoSto()\n      uiaConc <- round((uiaPoSto() / 100) * tan, 6)\n      # 2. calc critTan from input$critTanVal & (uiaPoSto()\n      calcCritTan <- round(crit_tan / (uiaPoSto() / 100.0), 6)\n      # 3. CHECK:\n      uiaConcAtCritTan <- round((calcCritTan * uiaPoSto() / 100.0), 6)\n      \n      \n      if(tan > crit_tan) {\n        \n        critPh_FREE <- critPhFreeForTanMillero(tan, crit_tan, temp, sal)\n        \n        critPh_NBS <- critPh_FREE - log10(ahFreeToSwsFactor(sal, temp, 0)) -\n          log10(ahSwsToNbsFactor(sal, temp, 0))\n        \n        critPh_NBS <- round(critPh_NBS, 3)\n        critPh_NBS_alert <- round(critPh_NBS - 0.20, 3)\n      }\n      \n      # str <- paste0(round((uiaPoSto() / 100) * tan, 6),' mg UIA/L')\n      # str <- 'undefined when crit-TAN = 0 mg/L'\n      # str <- 'undefined when TAN = 0 mg/L'\n      # str <- 'undefined when TAN < UIA'\n      \n      if(ph >= critPh_NBS) {\n        \n        thumbs = 'thumbs-down'\n        col = 'red'\n      } else if(ph >= critPh_NBS_alert) {\n        \n        thumbs = 'alert'\n        col = 'yellow'\n      } else {\n        \n        thumbs = 'thumbs-up'\n        col = 'green'\n      }\n      \n      str <- paste0(round((uiaPoSto() / 100) * tan, 6),' mg UIA/L')\n      \n    } else {\n      \n      thumbs = 'alert'\n      col = 'yellow'\n      str <- 'UIA undefined when TAN = 0'\n    }\n\n    # if(uiaConc - uiaConcAtCritTan >= 0) {\n    #   thumbs = 'thumbs-down'\n    #   col = 'red'\n    # } else {\n    #   thumbs = 'thumbs-up'\n    #   col = 'green'\n    # }\n\n    # NB: On the FREE scale\n    # NB: pH(NBS) = pH(Free) -\n    #               log10(ahFreeToSwsFactor(S,T(Kelvin),0)) -\n    #               log10(ahSwsToNbsFactor())\n\n    infoBox(\n      # value = paste0(uiaConc,' mg UIA/L'),\n      value = str,\n      # value = HTML(str_1, str_2, sep = '<br/>'),\n      \"Un-ionized Ammonia\",\n      # value = paste0(uiaConc,' mg/L (critical pH: ',critPh_NBS,')'), \"Un-ionized Ammonia\",\n      icon = shiny::icon(thumbs, lib = \"glyphicon\"),\n      color = col,\n      fill = T\n    )\n  })\n  \n\n  # output$critPhValBox <- renderValueBox({\n  # # output$critPhValBox <- renderInfoBox({\n  # \n  #   # *** [HANDLE] case where input$tanVal == 0\n  #   if(0 == icTanVal() | is.null(icTanVal()) | is.na(icTanVal())) {\n  #     str <- 'undefined when TAN = 0 mg/L'\n  #     thumbs = ''\n  #     col = 'yellow'\n  #   } else if(0 == input$critTanVal | is.null(input$critTanVal)) {\n  #     str <- 'undefined when crit-TAN = 0 mg/L'\n  #     thumbs = ''\n  #     col = 'yellow'\n  #   } else {\n  # \n      # critPh <- critPhFreeForTanMillero(icTanVal(), input$critTanVal, icTemp(), icSal())\n      # critPh_NBS <- critPh - log10(ahFreeToSwsFactor(icSal(),icTemp(), 0)) -\n      #                      log10(ahSwsToNbsFactor(icSal(),icTemp(), 0))\n  # \n  # \n  #     # cat('****    critPh_NBS = ', critPh_NBS,'\\n')\n  #     # cat('**** input$phSlide = ', input$phSlider,'\\n\\n')\n  # \n  # \n  #     str <- paste0('pH ', round(critPh_NBS, 4), ' (', round(input$phSlider - critPh_NBS, 4), ')')\n  # \n  #     if(round(critPh_NBS, 5) <= input$phSlider) {\n  #       thumbs = 'thumbs-down'\n  #       col = 'red'\n  #     } else if((round(critPh_NBS, 5) - input$phSlider) <= 0.3) {\n  #       thumbs = 'alert'\n  #       col = 'orange'\n  #     } else {\n  #       thumbs = ''\n  #       col = 'yellow'\n  #     }\n  #   }\n  # \n  #   # infoBox(\n  #   valueBox(\n  #     value = str,\n  #     \"Critical pH\",\n  #     icon = shiny::icon(thumbs, lib = \"glyphicon\"),\n  #     color = col\n  #   )\n  # })\n  \n  \n  # ---- observe(input$salUnits ... ----\n  \n  \n  # see: http://shiny.rstudio.com/reference/shiny/latest/updateSliderInput.html\n  observe({\n\n    sal_units <- input$salUnits\n\n    if (is.null(sal_units))\n      return()\n\n    idx <- which(sal_units == salUnitsList)\n    # sal <- salToIcUnits(salSet[idx], idx, 30+273.15, 0)\n\n    cat('\\n\\n*****\\nsalSlider CHANGED!!\\nsalMin[idx]: ', salMin[idx],\n        '\\n salMax[idx]: ', salMax[idx],\n        '\\n salSet[idx]: ', salSet[idx],'\\n*****\\n\\n')\n\n  # Control the value, min, max, and step.\n    updateSliderInput(session, \"salSlider\", value = salSet[idx],\n                      min = salMin[idx], max = salMax[idx])\n  })\n  \n  # observeEvent(input$salUnits, {\n  #   idx <- which(input$salUnits == salUnitsList)\n  #   sal <- salToIcUnits(salSet[idx], idx, 30+273.15, 0)\n  #   cat('\\n\\n*****\\nsalSlider CHANGED!! input$salSlider: ', input$salSlider, '\\n sal: ', sal,'\\n*****\\n\\n')\n  # })\n  \n  \n  # ---- DT ----\n  # see: http://stackoverflow.com/questions/38725505/interactive-datatable-keep-column-filters-after-rerendering-the-table/38753713#38753713\n  # and: https://rstudio.github.io/DT/shiny.html (2.3 Manipulate An Existing DataTables Instance)\n  #     app = system.file('examples', 'DT-reload', package = 'DT') ; shiny::runApp(app)\n  # code: https://github.com/rstudio/DT/blob/master/inst/examples/DT-reload/app.R\n  df <- reactive({\n      \n      if(is.null(input$tempSlider))\n        temp <- initValues$t\n      else {\n        idx <- which(input$tempUnits == tempUnitsList)\n        temp <- tempToIcUnits(input$tempSlider, idx)\n      }\n\n      \n      if(is.null(input$salSlider))\n        sal <- initValues$s\n      else {\n        sal <- input$salSlider\n        \n        # idx <- which(input$salUnits == salUnitsList)\n        \n        # cat(' 1.   input$salSlider:',input$salSlider, '\\n')\n        # \n        # cat('----- END RENDER SLIDER -------\\n')\n        # \n        # cat('--------------------------\\n')\n        # cat('         input$salUnits: ', input$salUnits, '\\n')\n        # cat('salUnitsList[', idx, ']: ', salUnitsList[idx], '\\n')\n        # cat('      salMin[', idx, ']: ', salMin[idx], '\\n')\n        # cat('      salMax[', idx, ']: ', salMax[idx], '\\n')\n        # cat('      salSet[', idx, ']: ', salSet[idx], '\\n')\n        # cat('        input$salSlider:',input$salSlider, '\\n')\n        # cat('--------------------------\\n')\n        \n        # if(input$salSlider >= salMin[idx] && input$salSlider <= salMax[idx]) {\n        #   cat(' === GOOD ===\\n\\n')\n        #   sal <- salToIcUnits(input$salSlider, idx, temp, 0)\n        # } else {\n        #   cat(' === BAD ===\\n\\n')\n        #   sal <- salToIcUnits(salSet[idx], idx, temp, 0)\n        # }\n        \n      }\n      \n      \n      if(is.null(input$phSlider))\n        ph <- initValues$ph\n      else\n        ph <- input$phSlider\n      \n      tan <- input$tanVal\n      crit_tan <- input$critTanVal\n    \n      \n      # calcUiaPoSto(temp, sal)\n    \n      \n    # if(!is.nan(critPh_FREE)) {\n    if(tan > crit_tan) {\n      \n      critPh_FREE <- critPhFreeForTanMillero(tan, crit_tan, temp, sal)\n      \n      critPh_NBS <- critPh_FREE - log10(ahFreeToSwsFactor(sal, temp, 0)) -\n        log10(ahSwsToNbsFactor(sal, temp, 0))\n      \n      critPh_NBS <- round(critPh_NBS, 3)\n      \n      # critTan UNDEFINED when tan <= input$critTanVal ??\n      critTan <- round(input$critTanVal / (uiaPoSto() / 100.0), 4)\n      \n      # deltaPh <- round((input$phSlider - critPh_NBS), 4)\n      deltaTan <- round((input$tanVal - critTan), 4)\n      \n      deltaPh <- round((input$phSlider - critPh_NBS), 4)\n      \n    } else {\n      \n      shinyjs::info(\"TAN cannot be less than UIA\\nPlease enter either a higher TAN\\nor a lower UIA\")\n      \n      critPh_NBS <- 'n/a'\n      critTan <- 'n/a'\n      \n      deltaPh <- 'n/a'\n      deltaTan <- 'n/a'\n    }\n      \n      \n      # my_df <<- data.frame(pH = c(input$phSlider, round(critPh_NBS, 3), deltaPh),\n      #                      TAN = c(input$tanVal, critTan, deltaTan))\n      \n      my_df <<- data.frame(now = c(input$phSlider, input$tanVal),\n                           crit = c(critPh_NBS, critTan), diff = c(deltaPh, deltaTan))\n      \n      my_df\n      \n  })\n  \n  proxy = dataTableProxy('crit_data')\n  \n  observe({\n    # replaceData(proxy, df(), rownames = c('current', 'critical', '∆'), resetPaging = FALSE)\n    replaceData(proxy, df(), rownames = c('pH', 'TAN'), resetPaging = FALSE)\n  })  \n  \n  output$crit_data <- DT::renderDataTable(\n    \n    datatable( isolate(df()),\n                 \n                 # rownames = c('current', 'critical', '∆'),\n                 rownames = c('pH', 'TAN'),\n                 \n                 options = list(dom = 't',\n                                'bSort' = F,\n                                'bInfo' = F,\n                                # pageLength = 3,\n                                pageLength = 2,\n                                \n                                # see: https://rstudio.github.io/DT/010-style.html\n                                # columnDefs = list(list(targets = 4, visible = F),\n                                #                   list(className = 'dt-center', targets = c(1:3))),\n                                \n                                # see: http://rstudio.github.io/DT/options.html\n                                initComplete = JS(\n                                  \"function(settings, json) {\",\n                                  \"$(this.api().table().header()).css({'background-color': 'orange', 'color': '#000'});\",\n                                  \"}\")\n                                \n                 )\n      )\n  )\n  \n  \n  # ---- output DISINFECTION ----\n  \n  output$result <- renderUI({\n    \n    str1 <- paste0('ADD ',round(volDisinfectantToAdd(),2),' ',input$disinfectUnitsToAdd,\n                   ' of ',input$poStoSlider,'% stock solution')\n    str2 <- paste0('to ',input$totVolToDisinfect,' ',input$disinfectUnitsTot)\n    str3 <- paste0('to get a disinfectant concentration of ',input$ppmSlider,' ppm')\n    \n    HTML(paste(tags$h2(str1), tags$h2(str2), tags$h2(str3), sep = '<br/>')) \n  })\n  \n  # output$poStoToPpmVal <- renderValueBox({\n  #   \n  #   # print(volDisinfectantToAdd())\n  #   # cat(input$ppmSlider / (10 * input$poStoSlider),' ml/L',\n  #   #     ' -> ', volDisinfectantToAdd(), input$disinfectUnitsToAdd, '\\n')\n  #   # \n  #   # cat('add',volDisinfectantToAdd(),input$disinfectUnitsToAdd,\n  #   #     'of',input$poStoSlider,'% solution to',input$totVolToDisinfect,input$disinfectUnitsTot,\n  #   #     'to get',input$ppmSlider,'ppm\\n\\n')\n  #   \n  #   valueBox(\n  #     value = disinfectResult(),\n  #     # value = paste0('add ',round(volDisinfectantToAdd(),2),' \\n',input$disinfectUnitsToAdd,\n  #     #                ' of\\n',input$poStoSlider,'% solution to get\\n',\n  #     #                input$ppmSlider,' ppm'),\n  #     \"\",\n  #     icon = shiny::icon('thumbs-up', lib = 'glyphicon'),\n  #     color = 'green'\n  #   )\n  # })\n}\n# )",
    "created" : 1472504534567.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1769603522",
    "id" : "467573DD",
    "lastKnownWriteTime" : 1472602391,
    "last_content_update" : 1472602392073,
    "path" : "~/R Projects/WQ iQuaCalc Lite/server.R",
    "project_path" : "server.R",
    "properties" : {
        "docOutlineVisible" : "0"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}