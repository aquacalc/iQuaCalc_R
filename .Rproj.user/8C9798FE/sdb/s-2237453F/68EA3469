{
    "collab_server" : "",
    "contents" : "# converter.R used in iQuaCalc (Lite) Shiny app\n\n# load CarbCalc 'brains'\nsource('CarbCalc.R')\n\n\n# ---- get DIC ----\n\n# temp, sal, & [Alk]s passed in as I.C. units\ngetInitAndFinalDic <- function(temp, sal,\n                               initPh, initAlk,\n                               finalPh, finalAlk) {\n  \n  initPhFREE<-phNbsToPhFree(initPh,sal,temp,0)\n  initDic<-calcDicOfAlk(initAlk,initPhFREE,temp,sal)\n  \n  finalPhFREE<-phNbsToPhFree(finalPh,sal,temp,0) \n  finalDic<-calcDicOfAlk(finalAlk,finalPhFREE,temp,sal)\n  \n  cat('\\n\\n')\n  cat('in getInitAndFinalDic with  INIT pH...',initPh,' to ',initPhFREE,'\\n')\n  cat('in getInitAndFinalDic with FINAL pH...',finalPh,' to ',finalPhFREE,'\\n')\n  cat('in getInitAndFinalDic with     Alks...',initAlk,' to ',finalAlk,'\\n')\n  cat('in getInitAndFinalDic with     DICs...',initDic,' to ',finalDic,'\\n')\n  cat('\\n\\n')\n  \n  return(c(initDic,finalDic))\n  \n}\n\n\n# ---- get WQ state dataset for temp, sal, pH, & [Alk] ----\n# return as vector: dic, ...\n\ngetWqState <- function(temp,sal,ph,alk) {\n  \n  initPh<-input$initPh   ; initPhFREE<-phNbsToPhFree(input$initPh,input$salInPpt,temp,0)\n  initAlk<-input$initAlk ; initDic<-1000*calcDicOfAlk(initAlk/1000,initPhFREE,temp,input$salInPpt)\n  \n  finalPh<-input$finalPh   ; finalPhFREE<-phNbsToPhFree(finalPh,input$salInPpt,temp,0) \n  finalAlk<-input$finalAlk ; finalDic<-1000*calcDicOfAlk(finalAlk/1000,finalPhFREE,temp,input$salInPpt)\n  \n  initCo2<-calcCo2OfDic(initDic,temp,input$salInPpt,initPhFREE)\n  finalCo2<-calcCo2OfDic(finalDic,temp,input$salInPpt,finalPhFREE)\n  \n  # some calcs for WQ display\n  rho<-calcRho(temp,input$salInPpt)\n  kspca<-calcKspCa(temp,input$salInPpt)\n  kspar<-calcKspAr(temp,input$salInPpt)\n  k2<-getK2(temp,input$salInPpt,0)\n  caMolin<-convertCaToMolesPerKg (input$ca,temp,input$salInPpt)\n  \n  initOmegaCa<-calcOmegaCa(initDic/1000,caMolin,temp,input$salInPpt,initPhFREE)\n  initOmegaAr<-calcOmegaAr(initDic/1000,caMolin,temp,input$salInPpt,initPhFREE)\n  finalOmegaCa<-calcOmegaCa(finalDic/1000,caMolin,temp,input$salInPpt,finalPhFREE)\n  finalOmegaAr<-calcOmegaAr(finalDic/1000,caMolin,temp,input$salInPpt,finalPhFREE)\n}\n\n\n# ---- user-defined validation ----\n\n# If return NULL, validate ignored and app proceeds as normal\n# If return a character string, validate fails and returns the string\n# If return FALSE, validate fails silently\n#    Shiny will not continue with the app (which would result in a red error message), \n#    but it will not display a grey validation error message either.\n\n\nvalidator<-function(input, comment, LL, UU, units) {\n  cat('in validate...',comment,'...',input,'...',LL,'...',UU,'...',units,'\\n')\n  w<-paste('Please enter a ',comment,' between ',LL,' and ',UU,' ',units)\n  \n  if(input < LL || input > UU) {\n    w\n  } else if(input == '' || !is.numeric(input)) {\n    #    FALSE\n    'Please enter a valid temperature value, eh?'\n  } else {\n    NULL\n  }\n}\n\n\n# ---- convert init and final [Alk] to I.C. units\nalkToIcUnits <- function(alk, alkIndex, icTemp, icSal) {\n  cat('alkToIcUnits(',alk,',',alkIndex,',',icTemp,',',icSal,')\\n')\n  rho<-calcRho(icTemp, icSal)\n  cat('rho = ',rho,'\\n')\n  \n  \n  if(1 == alkIndex) {\n    return(alk / 1000)\n  } else {   # convert from ppm CaCO3 to meq/kg\n    return( (alk  / 50.04345) / 1000 )\n  }\n  \n# ---- NB: OLD code, when drop-down list with meq/kg, meq/L, ppm CaCO3, & dK\n#   if(1 == alkIndex) {\n#     return(alk/1000)\n#   } else if(2 == alkIndex) {   # convert from meq/L to meq/kg\n#     return((alk/1000)  * (rho/1000))\n#   } else if(3 == alkIndex) {   # convert from ppm CaCO3 to meq/kg\n#     return((alk  / 50.04345) / 1000)\n#   }\n}\n\n# ---- vectors used in length conversions ----\nfractionsAsDecimals <- c(0.0000, 0.0625, 0.1250, 0.1875, 0.2500, 0.3125, 0.3750, 0.4375, 0.5000,\n                         0.5625, 0.6250, 0.6875, 0.7500, 0.8125, 0.8750, 0.9375, 1.0000)\nfractionsAsLiteral <- c('0', '1/16', '1/8', '3/16', '1/4', '5/16', '3/8', '7/16', '1/2',\n                      '9/16', '5/8', '11/16', '3/4', '13/16', '7/8', '15/16', '1')\n\n\n# ---- Convert meters to ft & in ----\n\n# getFractionsAsDecimals <- function() {\n#   # relate to nearest 1/16\" (or 1/32\")\n#   # compute decimal equivalent of fractinal inches\n#   smallestUnitInch <- 16\n#   fractions <- c()\n#   for(i in 0:smallestUnitInch) {\n#     fractions <- c(fractions, i / smallestUnitInch)\n#   }\n#   \n#   return(fractions)\n# }\n\nconvertMetersToFtAndInches <- function(meters) {\n  \n  if(is.na(meters) | meters == 0) { return(c(NA, NA)) }  ## numericInput field cleared or '0'\n  \n  ansDecimalFt <- meters * 3.280839895                 ## convert meters to ft, ans is decimal feet\n  \n  ansWholeFt <- floor(ansDecimalFt)                    ## get whole number of ft\n  \n  ansDecimalInch <- 12 * (ansDecimalFt - ansWholeFt)   ## calc decimal inches\n  \n  ansWholeInch <- floor(ansDecimalInch)                ## get whole number of inches\n  \n  ansFractionalInch <- ansDecimalInch - ansWholeInch   ## get remaining 'fractional' part of inches\n  \n  cat('           meters:',meters,'\\n')\n#   cat('     ansDecimalFt:',ansDecimalFt,'\\n')\n#   cat('       ansWholeFt:',ansWholeFt,'\\n')\n#   cat('   ansDecimalInch:',ansDecimalInch,'\\n')\n#   cat('     ansWholeInch:',ansWholeInch,'\\n')\n#   cat('ansFractionalInch:',ansFractionalInch,'\\n')\n#   cat('ansFractionalInch:',sprintf('%.54f',ansFractionalInch),'\\n')\n#   cat('======================================\\n')\n  \n  # which decimal expression of 16ths of an inch is >= the calculated ansFracionalInch\n#   cat('     which(fractionsAsDecimals >= ansFractionalInch):',\n#       which(fractionsAsDecimals >= ansFractionalInch),'\\n')\n#   cat('min(which(fractionsAsDecimals >= ansFractionalInch)):',\n#       min(which(fractionsAsDecimals >= ansFractionalInch)),'\\n')\n  \n  nextHighestSixteenthIdx <- min(which(fractionsAsDecimals >= ansFractionalInch))\n  nextHighestSixteenthVal <- fractionsAsDecimals[nextHighestSixteenthIdx]\n  \n  # adjust output to account for cases in which inch rounds to 1\" and/or 12:\n  \n  if(nextHighestSixteenthVal == '1') {\n    ansWholeInch = ansWholeInch + 1\n    nextHighestSixteenthIdx = 0\n  }\n  \n  if(ansWholeInch == 12) {\n    ansWholeFt = ansWholeFt + 1\n    ansWholeInch = 0\n  }\n  \n#   cat('                                                   input meters:',meters,'\\n')\n#   cat('                                              ansFractionalInch:',ansFractionalInch,'\\n')\n#   cat('                                    nextHighestSixteenthIdx - 1:',nextHighestSixteenthIdx - 1,'\\n')\n#   cat('                         fractions[nextHighestSixteenthIdx - 1]:',fractionsAsDecimals[nextHighestSixteenthIdx - 1],'\\n')\n#   cat('                                        nextHighestSixteenthIdx:',nextHighestSixteenthIdx,'\\n')\n#   cat('                             fractions[nextHighestSixteenthIdx]:',fractionsAsDecimals[nextHighestSixteenthIdx],'\\n')\n#   cat('abs(ansFractionalInch - fractions[nextHighestSixteenthIdx - 1]):',abs(ansFractionalInch - fractionsAsDecimals[nextHighestSixteenthIdx - 1]),'\\n')\n#   cat('    abs(ansFractionalInch - fractions[nextHighestSixteenthIdx]):',abs(ansFractionalInch - fractionsAsDecimals[nextHighestSixteenthIdx]),'\\n')\n  \n  if (nextHighestSixteenthIdx != 0) {\n    distanceToLL <- abs(ansFractionalInch - fractionsAsDecimals[nextHighestSixteenthIdx - 1])\n    distanceToUL <- abs(ansFractionalInch - fractionsAsDecimals[nextHighestSixteenthIdx])\n    \n#     cat('diff with LL:',distanceToLL,'\\n')\n#     cat('diff with UL:',distanceToUL,'\\n')\n    \n    # as default, round up to UL\n    roundToIdx <- nextHighestSixteenthIdx\n    if((distanceToLL < distanceToUL) & (nextHighestSixteenthIdx != 0 | nextHighestSixteenthIdx != 1))\n      roundToIdx <- roundToIdx - 1\n  } else {\n    roundToIdx <- 0\n  }\n  \n#   cat('.....\\n')\n#   cat(nextHighestSixteenthVal,'>=',ansFractionalInch,'\\n')\n#   cat(ansFractionalInch,'is between',fractionsAsLiteral[nextHighestSixteenthIdx - 1],\n#       'and',fractionsAsLiteral[nextHighestSixteenthIdx],'of an inch\\n\\n')\n#   \n#   cat(meters,'m =',ansWholeFt,\"'\",ansWholeInch,fractionsAsLiteral[roundToIdx],'\"\\n')\n  \n  # ansFtIn <- paste(ansWholeFt,\"' \",ansWholeInch,\"  \",fractionsAsLiteral[roundToIdx],\"\\\"\")\n  ansFtIn <- paste0(ansWholeFt,' ft  ',ansWholeInch,' ',fractionsAsLiteral[roundToIdx],' in')\n  \n#   cat('ansWholeFt / 3 =',ansWholeFt / 3,'\\n')\n#   cat('floor(ansWholeFt / 3() =',floor(ansWholeFt / 3),'\\n')\n  \n  ansWholeYd <- floor(ansWholeFt / 3)\n  ansWholeFt <- ansWholeFt - (3 * ansWholeYd)\n  ansYdFtIn <- paste0(ansWholeYd,' yd  ',ansWholeFt,' ft  ',ansWholeInch,' ',fractionsAsLiteral[roundToIdx],' in')\n  \n  # cat('ansFtIn:',ansFtIn,'  ansYdFtIn:',ansYdFtIn,'\\n')\n  \n  return(c(ansFtIn, ansYdFtIn))\n}\n\n\n# ---- Convert (YD,) ft & in to meters ----\n\nconvertYdFtAndInchesToMeters <- function(wholeYd, wholeFt, wholeInch, decimalInch) {\n  \n  # cat('\\n\\n\\nConverting YARDS, feet, and inches to meters (icUnits)\\n')\n  # print(wholeYd) ; print(wholeFt) ; print(wholeInch) ; print(decimalInch)\n  idxDecimal <- which(fractionsAsLiteral == decimalInch)\n  # cat('index of', decimalInch, 'in',fractionsAsLiteral,'is',idxDecimal, '\\n')\n  decimalInch <- fractionsAsDecimals[idxDecimal]\n  \n  wholeFtTotal <- 3 * wholeYd + wholeFt\n  \n  metersFromWholeFt <- wholeFtTotal / 3.280839895\n  \n  metersFromWholeInch <- (wholeInch / 12) / 3.280839895\n  \n  metersFromDecimalInch <- (decimalInch / 12) / 3.280839895\n  \n#     print('--------------------------------------\\n')\n#     print('--------------------------------------\\n')\n#     print(fractionsAsDecimals)\n#     print(decimalInch)\n    \n#     print(fractionsAsDecimals[2])\n#     print(fractionsAsDecimals[16])\n#     cat('fractionsAsDecimals[', decimalInch, '] =', fractionsAsDecimals[idxDecimal], '\\n')\n#     cat('wholeFtTotal:', wholeFtTotal, '\\n\\n')\n#     cat(metersFromWholeFt,'+',metersFromWholeInch,'+',metersFromDecimalInch,'=\\n')\n#     cat(metersFromWholeFt + metersFromWholeInch + metersFromDecimalInch,'\\n')\n#     print('--------------------------------------******\\n')\n#     print('--------------------------------------******\\n')\n  \n  return(metersFromWholeFt + metersFromWholeInch + metersFromDecimalInch)\n}\n\n\n# ---- [DEPRECATED] ----\nconvertFtAndInchesToMeters <- function(wholeFt, wholeInch, decimalInch) {\n  \n  print('YADDA YADDA -- convertFtAndInchesToMeters -- YADDA YADDA')\n  \n  cat('\\n\\n\\nConverting feet and inches to meters (icUnits)\\n')\n  metersFromWholeFt <- wholeFt / 3.280839895\n  \n  metersFromWholeInch <- (wholeInch / 12) / 3.280839895\n  \n  metersFromDecimalInch <- (decimalInch / 12) / 3.280839895\n  \n#   print('--------------------------------------\\n')\n#   print('--------------------------------------\\n')\n#   cat(metersFromWholeFt,'+',metersFromWholeInch,'+',metersFromDecimalInch,'=\\n')\n#   cat(metersFromWholeFt + metersFromWholeInch + metersFromDecimalInch,'\\n')\n#   print('--------------------------------------\\n')\n#   print('--------------------------------------\\n')\n  \n  return(metersFromWholeFt + metersFromWholeInch + metersFromDecimalInch)\n}\n\n\n\n\n# ---- abstract converter (get one converted value) ----\n\nconvert <- function(fromVal, fromUnits, toUnits, type) {\n  \n  fromIdx <- which(fromUnits == type$units)\n  \n  toIdx <- which(toUnits == type$units)\n  \n  icFromVal <-  fromVal / type$factors[fromIdx]\n  \n  return(icFromVal * type$factors[toIdx])\n}\n\n\n# ---- convert BIOMASS ----\n# leverage convertAll() to go between per-unit-volume & per-unit-area\n\n# need depth converted to meters (icUnits for depth, z)\n# lengthUnits <- c(\"m\", \"cm\", \"mm\",\n# \"yd\", \"ft\", \"in\",\n# \"ft & in\", \"yd, ft, & in\")\n# volUnits <- c('milliliters (ml)', 'liters (L)', 'cubic meters (m\\U00B3)',\n#              'gallons (US)', 'gallons (UK)')\n# biomassUnits <- c('kg/m²', 'g/m²', 'lb/m²', 'lb/ft²',\n#                  'kg/m³', 'g/L', 'lb/gal (US)', 'lb/gal (UK)', 'lb/ft³')\nconvertDepth <- function(fromVal, fromUnits, type) {\n  \n  # get user-entered depth (z) in meters\n  icResult <- getInIcUnits(fromVal, fromUnits, length)\n  \n  cat(fromVal, fromUnits, '=> I.C. Depth =', icResult, '\\n')\n  \n  return(icResult)\n}\n\n\n#   fromVal: user-entered biomass value\n# fromUnits: user-entered biomass units (e.g., kg/m2, lb/gal (US), etc.)\n#      type: always 'biomass' to access conversion units and conversion factors\n#   icDepth: user-entered depth (converted, if need be) in meters\nconvertBiomass <- function(fromVal, fromUnits, type, icDepth) {\n  \n  # are fromUnits per-unit-volume or per-unit-area?\n  if(fromUnits %in% type$units[1:4]) {        # choice is per-unit-AREA\n    \n    # print('sent per-unit-AREA units')\n    # convert to all AREA units\n    areaConversions <- convertAll(fromVal, fromUnits, type)\n#     print(areaConversions)\n#     print(areaConversions$values[1:4])\n#     cat('-------------------\\n')\n    # convert to all volume units\n#     print(icDepth)\n#     print(areaConversions$values[1] / icDepth)\n#     print(type$units[5])\n    \n    # cat(areaConversions$values[1] / icDepth, type$units[5],'\\n')\n    volumeConversions <- convertAll(areaConversions$values[1] / icDepth, type$units[5], type)\n    \n    convertedBiomass <- c(areaConversions$values[1:4], volumeConversions$values[5:9])\n    # cat('\\n-------- from AREA -----------\\n')\n    print(convertedBiomass)\n    \n    return(convertedBiomass)\n    \n  } else{                                     # choice is per-unit-VOLUME\n    \n    # print('sent per-unit-VOLUME units')\n    # convert to all VOLUME units\n    volumeConversions <- convertAll(fromVal, fromUnits, type)\n    \n    areaConversions <- convertAll(volumeConversions$values[1] * icDepth, type$units[1], type)\n    \n    convertedBiomass <- c(areaConversions$values[1:4], volumeConversions$values[5:9])\n    # cat('\\n-------- from VOLUME -----------\\n')\n    print(convertedBiomass)\n    \n    return(convertedBiomass)\n  }\n}\n\n\n# ---- get value in I.C. units ----\ngetInIcUnits <- function(fromVal, fromUnits, type) {\n  \n  fromIdx <- which(fromUnits == type$units)\n    \n  toIdx <- which(type$icUnits == type$units)\n    \n  icFromVal <-  fromVal / type$factors[fromIdx]\n    \n  return(icFromVal)\n  \n}\n\n\n# ---- convert to ALL units ----\n\nconvertAll <- function(fromVal, fromUnits, type) {\n  \n  # get the converted input in terms of Internal Calc units\n  icResult <- getInIcUnits(fromVal, fromUnits, type)\n  \n  # compute the vector of all conversions\n  allConversions <- c()\n  \n  for(f in type$factors) {\n    \n    # cat('which(f == 777.777):',type$units[which(type$factors == f)],'\\n')\n    if(f == 777.777 | f == 888.888) {\n      \n      if(f == 777.777)\n        ans <- convertMetersToFtAndInches(icResult)[1]\n      else\n        ans <- convertMetersToFtAndInches(icResult)[2]\n      }\n    else\n      ans <- f * icResult\n    \n    allConversions <- c(allConversions, ans)\n  }\n  \n  # df <- data.frame('units' = type$units, 'values' = round(allConversions, 6))\n  df <- data.frame('units' = type$units,\n                   'values' = allConversions, \n                   stringsAsFactors = F)\n  \n  return(df)\n}\n\n\n# ---- Convert Vol ----\n\n# when ic volume units are LITERS, then toLitersFactors vector is...\n# c(0.001, 1.0, 1000.0, 3.785412, 4.54609)\n# i.e., (x ml) * (0.001 L / ml) = 0.001x L\n#       (y gal (US)) * (3.785412 L / gal (US)) = 3.785412y L\nconvertVol <- function(fromVal, fromUnits, toUnits) {\n  \n  icUnits <- 'liters (L)'\n  \n  # get index of FROM UNITS, as defined by volUnitsList in global.R\n  fromIdx <- which(fromUnits == volUnitsList)\n  # fromIdx <- which(fromUnits == volumeUnitsChoices)\n  \n  # get index of TO UNITS, as defined by volUnitsList in global.R\n  toIdx <- which(toUnits == volUnitsList)\n  # toIdx <- which(toUnits == volumeUnitsChoices)\n  \n  # convert fromVal to icUnits (here, for volume, LITERS)\n  icFromVal <- fromVal / toLitersFactors[fromIdx]\n  \n#   cat('  fromVal:',fromVal,'\\n')\n#   cat('fromUnits:',fromUnits,'\\n')\n#   cat('  toUnits:',toUnits,'\\n')\n#   cat('  fromIdx:',fromIdx,'\\n')\n#   cat('    toIdx:',toIdx,'\\n')\n#   cat('icFromVal:',icFromVal,'\\n')\n#   cat('toLitersFactors[toIdx] =',toLitersFactors[toIdx],'\\n')\n#   \n#   cat('------------------------------\\n')\n#   cat(fromVal,fromUnits,'=',icFromVal * toLitersFactors[toIdx],toUnits,'\\n')\n#   cat('------------------------------\\n')\n  \n  # return converted value in toUnits\n  return(icFromVal * toLitersFactors[toIdx])\n}\n\n\n# ---- Convert Flow Rate ----\n\nconvertFlowRate <- function(fromVal, fromUnits, toUnits) {\n  \n  icUnits <- 'm³/d'\n  \n  # get index of FROM UNITS, as defined by volUnitsList in global.R\n  fromIdx <- which(fromUnits == flowRateUnitsList)\n  \n  # get index of TO UNITS, as defined by volUnitsList in global.R\n  toIdx <- which(toUnits == flowRateUnitsList)\n  \n  # convert fromVal to icUnits (here, for volume, LITERS)\n  icFromVal <-  fromVal / toCubicMetersPerDayFactors[fromIdx]\n  \n#     cat('**----------------------------\\n')\n#     cat(fromVal,fromUnits,'=',icFromVal * toCubicMetersPerDayFactors[toIdx],toUnits,'\\n')\n#     cat('**----------------------------\\n')\n  \n  # return converted value in toUnits\n  return(icFromVal * toCubicMetersPerDayFactors[toIdx])\n}\n\n\n# ---- Convert Temp ----\n\n# ic temperature units are KELVIN\ntempToIcUnits <- function(temp, tempUnitsIndex) {\n  if(1 == tempUnitsIndex) {\n    return(temp + 273.15)\n  } else if(2 == tempUnitsIndex) {\n    return( (5 * (temp - 32) / 9) + 273.15 )\n  } else {\n    return(temp)\n  }\n}\n\n# return df of all 3 temp conversions\n\n# when called WITH IC temp (KELVIN)\ntempToAllUnits <- function(temp_K) {\n  \n  # 1. convert K to C\n  temp_C <- temp_K - 273.15\n  \n  # 3. convert K to F\n  temp_F <- (9 / 5) * temp_C + 32\n  \n  temp_C <- round(temp_C, 2)\n  temp_F <- round(temp_F, 2)\n  temp_K <- round(temp_K, 2)\n  \n  df <- data.frame(vals = c(temp_C, temp_F, temp_K), \n                   units = c('C', 'F', 'K'))\n  \n  return(df)\n}\n\n# when called WITHOUT IC temp (KELVIN)\n# tempToAllUnits <- function(temp, tempUnitsIndex) {\n#   \n#   # 1. convert to IC units (KELVIN)\n#   temp_K <- tempToIcUnits(temp, tempUnitsIndex)\n#   \n#   # 2. convert K to C\n#   temp_C <- temp_K - 273.15\n#   \n#   # 3. convert K to F\n#   temp_F <- (9 / 5) * temp_C + 32\n#   \n#   df <- data.frame(vals = c(temp_C, temp_F, temp_K), \n#                    units = c('C', 'F', 'K'))\n#   \n#   return(df)\n# }\n\n\n# ---- Convert Sal to I.C. Units, (ppt) g/kg----\n\n# convert to all units\n# @param h_input_val, entered hydrometry value\n# @param h_input_idx, entered hydrometry units index\n# @param sal in IC units (ppt)\n# @param temp in IC units (K)\n# @param tc, hydrometry temp correction, boolean\n\n# Answers the Q: What is the hydrometer reading for sal in K?\n# salToAllUnits <- function(h_input_val, h_input_idx, sal, temp, tc) {\n\n\nsalToAllUnits <- function(sal, temp) {\n\n  # *** convert temp in K to temp in C for methonds below\n  temp <- temp - 273.15\n\n  # bisection search for equivalent hydrometer data\n\n  t_standard  <- c( 4.0, 20.0, 15.5556, 25.0)\n  t_reference <- c(15.0, 20.0, 15.5556, 25.0)\n  \n  # difficult ERROR in inner k-loop, as c(0, 1) default typed as \"double\" when need \"integer\"\n  # MUST CAST\n  tc <- as.logical(c('FALSE', 'TRUE'))\n\n  tol  <- 0.0001\n\n  for(i in 1:length(t_standard)) {\n\n    for(k in tc) {\n\n      cat('k: ', k, ' tc[k]: ', tc[k],'\\n')\n      cat(class(tc[k]),'\\n')\n      \n      guess <- 0\n\n      low  <- 0.9900\n      high <- 1.0399\n\n      ans_h <- (low + high) / 2.0\n\n      test_sal <- calcSalOfSpGr(ans_h, temp, t_standard[i], t_reference[i], k)\n\n      while (abs(test_sal - sal) >= tol) {\n\n        guess <- guess + 1\n\n        if(test_sal < sal)\n          low <- ans_h\n        else\n          high <- ans_h\n\n        ans_h <- (low + high) / 2.0\n\n        test_sal <- calcSalOfSpGr(ans_h, temp, t_standard[i], t_reference[i], k)\n      }\n      cat('ans_h: ', ans_h,'\\n')\n    }\n    \n    # cat('ans_h: ', ans_h,'\\n')\n    # cat('guess: ', guess,'\\n\\n')\n  }\n  \n  # low  <- 0.9900\n  # high <- 1.0399\n  # \n  # ans_h <- (low + high)/2.0\n  # \n  # test_sal <- calcSalOfSpGr(ans_h, temp, t_standard[1], t_reference[1], tc)\n  # \n  # while (abs(test_sal - sal) >= tol) {\n  #   \n  #   # guess <- guess + 1\n  #   \n  #   if(test_sal < sal)\n  #     low <- ans_h\n  #   else\n  #     high <- ans_h\n  #   \n  #   ans_h <- (low + high)/2.0\n  #   \n  #   test_sal <- calcSalOfSpGr(ans_h, temp, 4.0, 15.0, tc)\n  # }\n  \n  # print(guess)\n  \n  # return(ans_h)\n}\n\n\n# @sal      - input salinity value\n# @salUnits - index of salinity units from drop-down widget\n# @temp     - temp passed in as I.C. units (K), but -- N.B. -- each auxiliary method requires Celcius\n# @tc       - temp correction flag for hydrometer conversions\n\n# ic salinity units are PARTS PER THOUSAND\nsalToIcUnits <- function(sal, salUnits, temp, tc) {\n  \n  # cat('    salToIcUnits, temp passed in: ', temp, '\\n')\n  # cat('salToIcUnits, salUnits passed in: ', salUnits, '\\n')\n  \n  # *** convert temp in K to temp in C for methonds below\n  temp <- temp - 273.15\n    \n#  '‰'=1,'μS/cm'=2,'S/m'=3,'mS/cm'=4,'dS/m'=5,\n#  '15C/4C'=6,'20C/20C'=7,'60F/60F'=8,'77F/77F'=9\n    if (1 == salUnits) {\n      # cat('PASSED IN...‰...sal: ', sal, ' temp: ', temp, '\\n')\n      return(sal)\n       \n    } else if (2 == salUnits) {     # ** NB: first convert to S/m\n        # cat('PASSED IN...μS/cm...sal: ', sal, ' temp: ', temp, '\\n')\n      # return(calcSwSalinityFromConductivity(4500 * 0.0001, temp, 0))\n      return(calcSwSalinityFromConductivity(sal * 0.0001, temp, 0))\n    } else if (3 == salUnits) {\n        # cat('PASSED IN...S/m...sal: ', sal, ' temp: ', temp, '\\n')\n        # return(calcSwSalinityFromConductivity(4500, temp, 0))\n        return(calcSwSalinityFromConductivity(sal, temp, 0))\n    } else if (4 == salUnits) {\n        return(calcSwSalinityFromConductivity(sal * 0.1, temp, 0))\n    } else if (5 == salUnits) {\n        return(calcSwSalinityFromConductivity(sal * 0.1, temp, 0))\n      \n    } else if (6 == salUnits) {\n        return(calcSalOfSpGr(sal, temp, 4.0, 15.0, tc))\n    } else if (7 == salUnits) {\n        return(calcSalOfSpGr(sal, temp, 20.0, 20.0, tc))\n    } else if (8 == salUnits) {\n        return(calcSalOfSpGr(sal, temp, 15.5556, 15.5556, tc))\n    } else {                        # ** 77F/77F\n        return(calcSalOfSpGr(sal, temp, 25.0, 25.0, tc))\n    }\n}\n\n# http://www.code10.info/index.php?option=com_content&view=article&id=65:conversion-between-conductivity-and-pss-78-salinity&catid=54:cat_coding_algorithms_seawater&Itemid=79\n#...valid within the temperature range between –2°C and +35°C, \n# pressure range between 0 and 10000 decibars and a practical salinity range between 2 and 42 \n# or the respective electrical conductivity and conductivity ratio.\n# Although practical salinity values < 2 are not defined, the equations deliver valid non-zero results \n# down to thresholds of conductivity ratios > 0.0005 and salinities > 0.02. \n# Values in these outer limits are estimates congruent with the Fortran algorithms (UNESCO 1983). \n# Below these thresholds functions return 0 (UNESCO 1983).\n\n# t in C and p in dbar\ncalcSwSalinityFromConductivity <- function(c, t, p) {\n  #            double sal = 0.0;\n  # ** NB: Must add myPressure and convert myConductivity to S/m for this calc\n  #            double t = myTemp;     // ** C\n  #            double p = myPressure; // ** dbar\n  \n# NB: With this algorithm, MUST CHANGE INPUT temp from KELVIN --> CELCIUS\n#     Unlike WQ Tech 0.95 in Xcode, this conversion performed in salToIcUnits()\n  \n  # ** @param c = C(S,t,p) is the measured electrical conductivity\n  # ** myConductivity = C(35,15,0) = electrical conductivity of standard SW,\n  # ** which is 4.2914 S/m\n  # ** e.g.: http://www.code10.info/index.php?option=com_content&view=article&id=65:conversion-between-conductivity-and-pss-78-salinity&catid=54:cat_coding_algorithms_seawater&Itemid=79\n  \n  # cat('*** calcSwSalinityFromConductivity ... c: ', c, '\\n')\n  \n  # ** S/m (or 42914 μS/cm) \n  myConductivity <- 4.2914\n  \n  # ** 1. calculate conductivity ratio R\n  myR <- c / myConductivity\n  \n  # ** 2. calculate rsubt -- function of temperature\n  c0 <- 0.6766097;      c1 <-  0.0200564\n  c2 <- 0.0001104259;   c3 <- -0.00000069698\n  c4 <- 0.0000000010031\n  \n  rSubT <- c0 + c1*t + c2*t*t + c3*t*t*t + c4*t*t*t*t\n  \n  # ** 3. calculate Rsubp -- function of pressure\n  e0 <- 0.00002070;      e1 <- -0.0000000006370\n  e2 <- 0.000000000000003989\n  d1 <- 0.03426;     d2 <-  0.0004464\n  d3 <- 0.4215;      d4 <- -0.003107\n  \n  RsubP <- 1 + p*(e0 + e1*p + e2*p*p) / (1 + d1*t + d2*t*t + (d3 + d4)* myR)\n  \n  # ** 4. calclate RsubT\n  RsubT <- myR / (rSubT * RsubP)\n  \n  # ** 5. calculate S'\n  k  <-  0.0162\n  b0 <-  0.0005; b1 <- -0.0056; b2 <- -0.0066\n  b3 <- -0.0375; b4 <-  0.0636; b5 <- -0.0144\n  \n  Sprime <- (t - 15) / (1 + k*(t - 15))\n  \n  # cat('*** calcSwSalinityFromConductivity ... RsubT: ', RsubT, '\\n')\n  \n  Sprime <- Sprime * (b0 + b1*sqrt(RsubT) + b2*RsubT + \n                        b3*RsubT^(1.5) + \n                        b4*RsubT*RsubT + b5*RsubT^(2.5))\n  # cat('bbbbbbbbbbb??')\n  # cat('*** calcSwSalinityFromConductivity ... Sprime: ', Sprime, '\\n')\n  \n  # ** 6. finish it off to calc salinity\n  a0 <-  0.0080; a1 <- -0.1692; a2 <- 25.385\n  a3 <- 14.0941; a4 <- -7.0261; a5 <-  2.7081\n  \n  mySal <- a0 + a1 * sqrt(RsubT) + \n  a2 * RsubT + a3 * RsubT^(1.5) + \n  a4 * RsubT*RsubT + a5 * RsubT^(2.5) + \n  Sprime\n  \n  return(mySal)\n}\n  \n\n# // ** TEST THIS METHOD TO CALC SALINITY from Sp. Gr.\n# // ** NB0: Must CHANGE TEMP for K (IC units) to Celcius\n# // ** NB1: changed params of original method in WqCalc\n# // **      from NSString to double\n# // ** NB2: 77 F / 77 F => (ref temp) / (standard temp)\n# // ** NB3: MUST trap case in which, for a given sample temp, a sp. gr. reading\n# // **      yields a salinity < 0.0\n\n# @tc       - temp correction flag for hydrometer conversions\ncalcSalOfSpGr <- function(spgr, tSample, tStandard, tReference, tc) {\n  \n  # cat('tc: ', tc, ' ... class(tc): ', class(tc),'\\n')\n  \n# NB: With this algorithm, MUST CHANGE INPUT temp from KELVIN --> CELCIUS\n#     Unlike WQ Tech 0.95 in Xcode, this conversion performed in salToIcUnits()\n#     (same with calcRhoFW and within calcSalFromSpGravity)\n         \n# calc densities at sample, reference, & standard tempertures\n# ** NB: in **THIS** implementation (vs. WqCalc), must add back 273.15 to pass Kelvin temp...\n    rhoSample     <- calcRhoFW(tSample + 273.15)\t\t  # should be 0.996542 at 27C??\n    rhoReference  <- calcRhoFW(tReference + 273.15)\t\t# should be 0.998232 at 20C??\n#\trhoStandard   = [carbCalc calcRhoFW:(tempStandard + 273.15)];\t\t// should be  at C??\n\n# cat('in CALC_SAL_OF_SPGR, SPGR:',spgr,'\\n')\n# cat('in CALC_SAL_OF_SPGR, temp:',tSample,'...',tStandard,'...',tReference,'\\n')\n# cat('in CALC_SAL_OF_SPGR, rho:',rhoSample,'...',rhoReference,'\\n')\n         \n    # 1: correct hydrometer reading with REFERENCE temp, if required\n         if (tc) {\n           \n          gamma <- 0.000030    # hydrometer coefficient of expansion (C^-1)\n         # ** check data correction: +0.0015 for sp. gr. hydrometer; -0.0002 for density hydrometer\n         \n          c <- spgr * (rhoReference / (rhoSample * (1 + gamma * (tSample - tReference))) - 1)\n         #   Rho  = -rhoReference * gamma * (tempSample - tempReference) / 1000; // mult by 1000 to express rho in g/ml\n          spgr <- spgr + c\n          \n         }\n         \n    # 2: calc sample salinity with CarbCalc method(s)\n# ** [KLUDGE] **\n# ** to 'help' VALIDATION & CONVERSION play nice...?\n\n      if(spgr >= 0.99 || spgr <= 1.0399)\n         mySal <- calcSalFromSpGravity(spgr,tSample,tStandard)\n      else\n         mySal <- 0.0\n         \n# NB: [KLUDGE] validate input to avoid returning mySal < 0...\n         if (mySal < 0 || mySal > 45) mySal <- 0\n         \n         \n         return(mySal)\n}\n         \n# ** NB: NB: NB: Temp sent in CELCIUS, *BUT* when send to calcRhoFW:,\n# **             now must send in KELVIN (unlike implementation in WqCalc project)\ncalcSalFromSpGravity <- function(spGrav, tempRead, tempCal) {\n  \n  A  <-   0.824493 - 0.0040899 * tempRead\n  A  <- A +   0.000076438 * tempRead * tempRead\n  A  <- A +  -0.00000082467 * tempRead^3\n  A  <- A +   0.0000000053875 * tempRead^4\n  \n  B  <-  -0.00572466 + 0.00010227 * tempRead\n  B  <- B +  -0.0000016546 * tempRead * tempRead\n  \n  C  <-   0.00048314\n \n  mySal <- calcSecantMethod(C, B, A, 0.0, calcRhoFW(tempRead+273.15) - calcRhoFW(tempCal+273.15) * spGrav)\n  \n  mySal <- mySal * mySal\n  \n  # cat('in CALC_SAL_**FROM**_SPGR:',spGrav,'...sample temp',tempRead,'...calibration temp',tempCal,'\\n')\n  # cat('...salinity = ',mySal,'\\n')\n    \n  return(mySal)\n}\n\n\n\n\n\n\n",
    "created" : 1472527482416.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2841045446",
    "id" : "68EA3469",
    "lastKnownWriteTime" : 1472602329,
    "last_content_update" : 1472602329190,
    "path" : "~/R Projects/WQ iQuaCalc Lite/converter.R",
    "project_path" : "converter.R",
    "properties" : {
        "docOutlineVisible" : "0"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}